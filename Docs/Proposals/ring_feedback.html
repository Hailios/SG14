<!DOCTYPE html><html><head><meta charset="utf-8"><title>ring_feedback.md</title><style></style></head><body id="preview">
<h1><a id="230915_CppCon_0"></a>23/09/15 CppCon</h1>
<p>rolling queues/ring: LEWG. Sg14: D0059R0,<a href="https://github.com/WG21-SG14/SG14/blob/master/Docs/Proposals/RingProposal.pdf">https://github.com/WG21-SG14/SG14/blob/master/Docs/Proposals/RingProposal.pdf</a><br>
<strong>GD:</strong> std::queue causes fragmentation problems. Fixed-size &lt;= 1 allocation. Why ‘ring’?<br>
<code>circular_buffer</code> already in boost, quite different. <code>rolling_queue</code> looks strange. <code>cyclic_buffer</code> and <code>ring_buffer</code> have <code>_buffer</code> and this is an adaptor. Looks like std::queue.<br>
Exceptions: push and emplace may fail because ring is full. You might not care and be happy to overwrite older entries.<br>
Open suggestion: aggressive_push and aggressive_emplace.<br>
vector allows decide ring size at run-time and array at compile-time.<br>
e.g. with vector, items only created when actually used in ring.<br>
std::array -&gt; static_ring and std::vector -&gt; dynamic_ring.<br>
In many places already use ring. When first suggested in discussion group, 6 implementations were submitted by other members.<br>
On to the paper. Synopsis not complete for dynamic_ring.<br>
<strong>Scott:</strong> This is a wrapper right? Should array be a parameter? Why different classes? Why not array and vector be type parameter of a single class template?<br>
<strong>GD:</strong> One reason instantiation an issue. Reason two: not knowing size of vector<br>
<strong>LC:</strong> Another proposal submitted. Far more concurrency-related version. Paper: n3353<br>
<strong>MW:</strong> Has to deal with concurrent erasure which is tough problem. Advises GD to look through other paper.<br>
<strong>LC:</strong> Doesn’t expect them to be unified.<br>
<strong>GD:</strong> Purpose of this proposal is to avoid allocations.<br>
<strong>LC:</strong> But there might be cross-fertilization and they should be distinct.<br>
<strong>Q:</strong> Why not use perfect forwarding to pass array/vector to a unified class template c’tor? And what kind of iterators are they?<br>
<strong>GD:</strong> FIFO iterators. No plan to run iterator over queue. (Ones in synopsis are boilerplate / internal.) Aims to make interface the same as std::queue.<br>
<strong>BR:</strong> std::array can be expensive to move. So maybe not such a great idea.<br>
<strong>Scott:</strong> Is this connected to discussion of fixed-sized containers?<br>
<strong>GD:</strong> Both of these meant to be fixed sized. The names, dynamic_ and static_ are no concrete design decision currently.<br>
<strong>Q:</strong> Buffer overrun: map has try_emplace(?) perhaps try_emplace here<br>
<strong>GD:</strong> &lt;not recorded&gt;<br>
<strong>Bob:</strong> fixed_ring instead of static_ring.<br>
<strong>GD:</strong> Yes.<br>
<strong>Bob:</strong> Lifetimes using c’tor / d’tor (?)<br>
<strong>Q:</strong> Way to construct dynamic_ring from fixed_ring? E.g. when run out of space with static_ring?<br>
<strong>GD:</strong> Not implemented. Good idea.<br>
<strong>Q:</strong> Recommend don’t bikeshed names. The library working group will do all of this. They know this stuff! You can actually leave things unnamed and they will just take care of it.<br>
<strong>Authur:</strong> Retracting uninitialized storage suggestion. How do we do this with vector and array. How does construction happen.<br>
<strong>GD:</strong> static_ size starts ready-constructed and dynamic_‘s elements get constructed as they are pushed - just like the two rings’ underlying storage types.<br>
<strong>Authur:</strong> How to tell empty / capacity?<br>
<strong>DG:</strong> Can look at iterators. No capacity.<br>
<strong>Authur:</strong> so for static_ is emplace a misnomer because array elements are around all the time.<br>
<strong>GD:</strong> Popping doesn’t destroy. Was tried. Was a mess. The details of conversation with Jon Wakely will be added to paper.<br>
<strong>SM:</strong> Ranged-based creation or assignment iterating through all the objects would make it easier to convert from static_ to dynamic_.<br>
<strong>Charles:</strong> More concerns. Uninitialized buffer instead of buffer so c’tor / d’tor called - same as for dynamic_ suggested. By extension maybe this isn’t an adaptor.<br>
<strong>Q:</strong> If you have a container that manages this, you can still keep it as an adaptor.<br>
<strong>GD:</strong> Maybe deal with this with template parameter on static_ring.<br>
<strong>Ville:</strong> Non-assignable elements are the reason for need for emplace in interface.<br>
<strong>Q:</strong> If I just have allocated memory, I feel I should be able to use that with this adaptor. Could you use array_view and make that the adaptor? Would keep ability to allocate everything at once.<br>
<strong>Ville:</strong> Moving the container into the ring is another option. Then no double-allocation.<br>
<strong>GD:</strong> Both have container move constructor.<br>
<strong>Ville:</strong> So already possible to avoid double-allocator.<br>
<strong>Q:</strong> Reiterates idea of passing a block of memory.<br>
<strong>Scott:</strong> begin and end might be tricky? The situation when begin and end are the same.<br>
<strong>GD:</strong> ring is FIFO. No intention to iterate through the buffer.<br>
<strong>Q:</strong> Could ring be more like a ring?<br>
<strong>GD:</strong> Not thought about it.<br>
<strong>MW:</strong> Suggests Arthur work with GD on this.<br>
<strong>Ville:</strong> non owning view is very different trade-off. Passing by values then poses different set of problems. And when you return them by value - very different set of problem.<br>
<strong>Q:</strong> Could static_ring be composed of container and view?<br>
<strong>MW:</strong> Now potentially looking at new proposal.<br>
<strong>GD:</strong> Happy to develop this paper in response to feedback. Rather not turn this into a swiss army knife that gets turned down.<br>
<strong>JM:</strong> Suggests static_ring and dynamic_ring don’t deal with object lifetime within interface.<br>
MW &amp; GD discuss how to proceed given many suggestions.<br>
<strong>MW:</strong> Revise before Friday but vote in the mean time about whether we ‘think’ we’ll like.<br>
<strong>Ville:</strong> Yes, can cast general ‘up’/‘down’ vote that suggests whether if warrants continued development - as opposed to voting on passing it right now.<br>
<strong>MW:</strong> We could even work on it today and vote late today.<br>
‘Up’ / ‘Down’ vote shows support by show of hands. Guy to continue to work on it until Friday</p>
<hr>
<h1><a id="191015_Kona_64"></a>19/10/15 Kona</h1>
<p>Circular-buffer queues<br>
<a href="https://issues.isocpp.org/show_bug.cgi?id=129">https://issues.isocpp.org/show_bug.cgi?id=129</a><br>
Latest paper<br>
<a href="https://issues.isocpp.org/attachment.cgi?id=10">https://issues.isocpp.org/attachment.cgi?id=10</a><br>
Previous discussion</p>
<p>Author</p>
<p>Presenter<br>
Guy Davidson<br>
Latest update<br>
<a href="http://wiki.edg.com/twiki/pub/Wg21kona2015/SG14/D0059R2.pdf">http://wiki.edg.com/twiki/pub/Wg21kona2015/SG14/D0059R2.pdf</a><br>
Pre-meeting comments<br>
Discussing: <a href="https://issues.isocpp.org/attachment.cgi?id=10">https://issues.isocpp.org/attachment.cgi?id=10</a></p>
<p>Meeting discussion</p>
<p>Small group discussion (Thursday AM)<br>
Attendees<br>
Michael Wong (MW)<br>
Patrice Roy (PR)<br>
Billy Baker (BB) [Scribe]<br>
Arthur O’Dwyer (AO)<br>
Bill Seymour (BS)<br>
Howard Hinnant (HH)<br>
Juan Alday (JA)<br>
Alan Talbot (AT)</p>
<p>Presentation and discussion<br>
Review of D0059R2<br>
MW presents<br>
<strong>PR:</strong> the topic is something that is written quite a bit<br>
<strong>AO:</strong> there are additional ongoing explorations in this same area<br>
<strong>MW:</strong> the circular_buffer in boost is a bit heavier than what is proposed<br>
<strong>MW:</strong> ring interface tries to match std::queue while having a fixed sized<br>
<strong>MW:</strong> author would like feedback on whether two classes should be created<br>
<strong>AT:</strong> why not just tweak queue<br>
<strong>AT:</strong> similar fixed/dynamic issues with a string implementation, used template parameters<br>
<strong>PR:</strong> the queue invariants don’t really apply here<br>
<strong>AO:</strong> the ongoing work is available in a gethub repository<br>
<strong>AO:</strong> D0059 owns memory (allocator aware) and not iterable<br>
<strong>PR:</strong> with the allocator, can’t use external storage<br>
<strong>AO:</strong> the ability to use external storage would be possible for both the fixed and dynamic cases<br>
<strong>AO:</strong> other work would be a complete rework of this paper<br>
<strong>AO:</strong> there is room for both D0059 as well as other work<br>
<strong>AO:</strong> example from Sony would not work with the D0059 interface<br>
<strong>HH:</strong> a synopsis is provided but not a specification, would like the specification before making a decision</p>
<p>back to author</p>
<p>Full group (Thursday PM)<br>
Attendees<br>
Jeffrey Yasskin (JY)<br>
Bill Seymour (BS)<br>
Patrice Roy (PR)<br>
Axel Naumann (AN)<br>
Lars Bjonnes (LB)<br>
Pete Becker (PB)<br>
Howard Hinnant (HH)<br>
Juan Alday (JA)<br>
Billy Baker (BB)<br>
Bryce Lollander (BL)<br>
Mike Spencer (MS)<br>
Titus Winters (TW)<br>
Alan Talbot (AT)<br>
Thomas Koeppe (TK)<br>
Arthur O’Dwyer (AO)<br>
Nico Josuttis (NJ)<br>
Jonathan Wakely (JW)</p>
<p>Presentation and discussion<br>
Discussion of the design.<br>
The buffer is a queue and never constructs/destroys, only assigns.<br>
It has fixed capacity and bounded size.<br>
<strong>AN:</strong> I don’t like that pop() doesn’t destroy. Rename the operation, or require that the element type be trivially destructible.<br>
<strong>TK:</strong> Why isn’t this a deque?<br>
<strong>JW:</strong> Because you can’t destroy from the middle of a vector.<br>
<strong>TK:</strong> Then don’t use a vector underneath.<br>
<strong>JY:</strong> For the use case of trivially destructible types, many of the design decisions become trivial.<br>
<strong>HH:</strong> 1) the “pop” is more like “remove” than “erase”, in that it doesn’t destroy anything. 2) Please send a specification rather than just a synopsis. It feels like we’re just guessing the semantics.<br>
<strong>TW:</strong> Without destructors, I can’t put refcounted things in.<br>
<strong>HH:</strong> I feel that this should not be in the standard. It’s fine for them to write code like that, but it doesn’t fit for the standard. I might feel different if it were marketed differently. For example, a “circular range” object would be interesting.</p>
<p>Polls:<br>
circular range/span (non-owning, points into an array of existing objects): 9<br>
owning buffer of once-constructed objects, assignment-only operations: 1<br>
buffer that constructs and destroys elements in-place as it goes along: 9<br>
compile-time sized: 12<br>
dynamic, fixed-size: 13<br>
dynamic, resizable: 5<br>
Should it support iteration?<br>
<code>SF F N A SA</code><br>
<code>2 6 5 3 0</code></p>
<hr>
<h1><a id="14316_GDC_160"></a>14/3/16 GDC</h1>
<p>Adapter type<br>
*Questions about iterators<br>
*Questions about concurrency<br>
*Questions about owning vs. non-owning</p>
<hr>
<h1><a id="1116_Issaquah_167"></a>11/16 Issaquah</h1>
<p>Michael Wong presenting on behalf of Guy Davidson<br>
Ring span is a circular buffer as SG14 like contiguous structures<br>
Changed from Ring buffer to span to reflect normal langauge as it is a view across non owned memory<br>
Referred back from LEWG in Oulu<br>
<strong>Nat:</strong> why is a requirement for single producer/ single consumer<br>
<strong>Hans:</strong> what is in mind is the avoidance of contention because producer and consumer are at opposite ends<br>
<strong>Michael:</strong> multi prod/cons adds overhead<br>
<strong>Will:</strong> notes that concurrent ring buffers are in wide use between hardware and software<br>
<strong>Detlef:</strong> How do I wait on space?<br>
Will and David discussed memory order constraints<br>
<strong>Will:</strong> this is acquire release in most operations<br>
<strong>Lawrence:</strong> Nothing else really makes sense<br>
<strong>David:</strong> we cannot allow default SC if this is really performance based<br>
<strong>Will and Lawrence:</strong> Comment that this is a sequential case with bolt ons and that is not working well<br>
<strong>David:</strong> does Olivier and Geoff discuss the intention of ContiguousIterator<br>
<strong>Geoff:</strong> The point of ContiguousIterator is to allow type erasure<br>
<strong>Nat:</strong> respond to Will’s observation. Notes that the author state that this is not a concurrent ring but rather is adapted from a concurrent queue<br>
Michael seeks view from finance<br>
Thomas confirms that this is a use case in HFT<br>
Olivier concerned about single/single versus multi/multi which apparently involves a lot of razor blades and a close shave!<br>
<strong>Detlef:</strong> I would like to see a more compelling use case that this is different to Lawrence’s queue<br>
<strong>Lawrence:</strong> Has a sequential interface that requires a test pattern to enable access. Needs and extension to the interface<br>
<strong>Geoff:</strong> Why is there an iterator in this as it does not otherwise meet requirements?<br>
<strong>Lawrence:</strong> This is for debugging purposes as it allows you to work our why it crashed. But in concurrent use this has issues<br>
<strong>Neil:</strong> I don’t think that that can be the motivation, it does not feel appropriate to SG14 type use cases if Lawrences motivation is correct<br>
<strong>Nat:</strong> We may need<br>
<strong>Thomas:</strong> This is a view type and thus has an underlying container.<br>
<strong>Paul:</strong> Can we use a trait to support the iterator.<br>
<strong>Hans:</strong> We need to performance justification.<br>
<strong>Lawrence:</strong> history buffer and communication buffer are different things<br>
<strong>Nat:</strong> Are there concurrent ring span use cases that cannot be addressed by the concurrent queue<br>
<strong>Michael:</strong> get the authors to work with Lawrence<br>
<strong>Nat:</strong> Use of an adaptor over another container, is mostly an avoidance of memory allocation, there is at least one impl of Lawrence’s queue that can do this. Can Lawrence’s queue be adapted to work over an underlying memory?<br>
<strong>Detlef:</strong> Push_back is different in serial versus concurrent, this is not acceptable in a single data structure.<br>
<strong>Hans:</strong> We really need to understand why the two different use cases are represented in a single impl, as this complicates matters<br>
<strong>Nat:</strong> Can we focus on the two cases of single/single multi/multi, not worry about the single/multi variants. Should direct the authors to come up with a use case for concurrent communication that is not captured in Lawrence’s queue.<br>
<strong>Maged:</strong> Notes that the single/multi variants can have special performance optimizations<br>
<strong>Olivier:</strong> To counter Nat, we need a non-concurrent sequential and a multi/multi/concurrent. Thus two interfaces, sequential and concurrent are the two that we need. sequential is the single/single while multi/multi should be defined in terms of concurrent queue. Divorce the two interfaces as they are no compatible with one another. Our job is to provide the correct vocabulary for interfaces. Implementations are free to innovate but the user gets standardised API. Advice to split this in to two papers. Thread unsafe goes straight to LEWG. SG1 is concerned with the concurrent and there are severe reservations around iterators In order to allow the association between the underlying and the span, we need to be able to access the head and tail positions directly.<br>
<strong>Hans:</strong> Java APIs would typically snapshot, is this something we can consider.<br>
<strong>Michael summary:</strong><br>
If concurrent interface is to remain we need a strong justification for divergence from Lawrence’s interface.<br>
A performance argument would probably need to be more precise about memory ordering.<br>
Divorce the <code>concurrent_ring_span</code> and <code>ring_span</code> (<code>ring_span</code> can go to LEWG).<br>
<code>concurrent_ring_span</code> deferred to <code>concurrent_queue</code></p>
<hr>
<h1><a id="0317_Kona_214"></a>03/17 Kona</h1>
<p>From the LEWG Wiki :</p>
<p>Meeting discussion<br>
Please invite the following people when the paper is discussed:<br>
Arthur O’Dwyer<br>
Michael Wong<br>
Walter E Brown</p>
<p>Day AM/PM (In case there are multiple discussions)<br>
Discussing: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0059r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0059r3.pdf</a></p>
<p>Attendees (If the notetaker can gather this)<br>
Bryce Adlestein-Lelbach<br>
Hal Finkel<br>
Patrice Roy<br>
Tim Shen<br>
Jeffrey Yasskin<br>
Mark Zeren</p>
<p>Presentation and discussion<br>
<strong>Hal:</strong> like standardizing something called *_popper<br>
<strong>Patrice:</strong> I think they did the job that was asked of them (fixed size, no iterators, policy-based poppers)<br>
<strong>Jeffrey:</strong> I’m glad the name ring’s gone. Too much mathematics-related meaning<br>
<strong>Jeffrey:</strong> why not circular_buffer?<br>
<strong>Bryce:</strong> if we keep ring_span, I’d like the relation to span to be clarified<br>
<strong>Jeffrey:</strong> it’s because it does not own memory<br>
<strong>Bryce:</strong> users might be surprised<br>
<strong>Mark:</strong> in a sense, it does not let you get chunks from it<br>
<strong>Patrice:</strong> *_buffer would be weird too, as it’s non-owning<br>
<strong>Jeffrey:</strong> *_buffer in networking is non-owning<br>
<strong>Jeffrey:</strong> I think a signed size_type would be useful here, like in the case of span, as it’s less error-prone<br>
<strong>Patrice:</strong> so ring_adapter would be better? (suggested by Hal)<br>
<strong>Hal:</strong> we want to separate this from allocator issues<br>
<strong>Bryce:</strong> it would be cool to have a default for users that don’t want to create a vector and adapt it. Not something to block the proposal, just something to think about<br>
<strong>Jeffrey:</strong> it was pretty much thought for POD types at first<br>
<strong>Patrice:</strong> it was made by / for games people<br>
<strong>Patrice:</strong> they allow moveable T iff T is nothrow-move-assignable<br>
<strong>Bryce:</strong> can it be constructed from an empty range? If so, they have a precondition on front() / back() and cannot be noexcept<br>
<strong>Hal:</strong> how does it signal error?<br>
<strong>Patrice:</strong> they assert. Technically, I think they want UB<br>
<strong>Bryce:</strong> they might get noexcept on front() / back(), but they’ll need faith<br>
<strong>Hal:</strong> it would require constraining the policy class<br>
<strong>Hal:</strong> this class should be so simple that it will all be inlined anyway<br>
<strong>Mark:</strong> we’ll have to use «throws : nothing» instead of noexcept<br>
<strong>Tim:</strong> I see begin() and end() in the member function pseudocode even though there are no iterators<br>
<strong>To summarize:</strong><br>
good in theory, wording needs work<br>
span might not be the right name (it doesn’t really match the other *_span classes)<br>
explore a companion container for the future<br>
it’s sometimes needed to build a ring on uninitialized memory buffers. The current design does not seem to support that<br>
this one’s fine; another that manages raw memory and destroy objects to is needed<br>
spec needed («this is implemented as…» is not a spec). Please look at std::queue. Bryce offers to help<br>
the rationale for «no iterator» needs work<br>
the rationale for having a separate buffer too<br>
clarify the rationale for the *_popper policies, particularly the non-default ones including alternatives<br>
noexcept should be «throws : nothing» as in the case of an empty range, operations have preconditions<br>
in general, the behavior of the class on an empty range needs to be described<br>
remove «synchronous» from push_back() and others (editorial)<br>
in the design decisions, we seem to be removing objects and releasing memory. It’s probably not true</p>
<p>Full LEWG Discussion:<br>
<strong>Patrice:</strong> (summarizing) Worries about name. Maybe ring_adaptor? Had debates about whether being non-owning is the right thing there. But it has been back and forth in previous meetings. Might be useful to have an adaptor class to make its usage simpler. Clear use case might be managing uninitialized memory. it might be a useful improvement to add that. Specs need some work, so does rationale. So overall a positive view but a number of things need some work.<br>
<strong>Jeffrey:</strong> Any questions for the full group?<br>
<strong>Patrice:</strong> No. Send it back with encouragement and things to work on.</p>

</body></html>