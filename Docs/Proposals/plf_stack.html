<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Replacing the std::stack container adaptor with the plf::stack container class</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
</HEAD>
<BODY>
LEWG, SG14: D0040R0
<BR>05-05-2016
<BR>Matt Bentley <br>mattreecebentley@gmail.com
<H1>Replacing the std::stack container adaptor with the plf::stack container class</H1>


<H2>I. Summary</H2>

<p>This document proposes replacing the current std::stack container adaptor with a higher-performance implementation of a stack, plf::stack, to achieve greater stack performance and performance-similarity across compilers.</p>

<H2>II. Motivation</H2>

<p>Stacks, as one of the simplest of abstract data types, should have adequate and predictable performance across implementations. With the current standard, the default adapted container used by std::stack is variable, and can be quite low-performance in many cases (eg. MSVC 2013). plf::stack is a different way of implementing a stack which has better performance than any STL container in a stack context, including std::vector and std::deque, across compilers. In addition it does not invalidate references to pushed elements (as obtained by the top() function) upon subsequent pushes, making it more suitable for some use-cases.</p>

<H2>III. Discussion </H2>
<p>No changes are necessary to the standard's interface for stack, only the underlying code.</p>

<p>

</p>
<H2>IV. Proposed Text</H2>

<p>Make the following changes in [specialized.algorithm]: <br>
<p>Modify: In the algorithm<u>s</u> uninitialized_copy <u>and uninitialized_move</u>, the template parameter InputIterator is required...</p>
<p>Modify: In the following algorithms <u> other than destroy</u>, if an exception is thrown there are no effects.</p>
Add:
<blockquote><pre><code>
	template&lt;class ForwardIterator&gt;
	void destroy(ForwardIterator begin, ForwardIterator end);
	
	<i>Effects:</i>
		typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type __t;
		while (begin != end)
		{
			begin-&gt;~__t();
			++begin;
		}

		
	template &lt;class InputIterator, class ForwardIterator&gt;
	ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);

	<i>Effects:</i>
		for (; first != last; ++result, ++first)
			::new (static_cast&lt;void*&gt;(addressof(*result)))
				typename iterator_traits&lt;ForwardIterator&gt;::value_type(std::move(*first));
		return result;
		
	template &lt;class InputIterator, class ForwardIterator&gt;
	ForwardIterator uninitialized_move_n(InputIterator first, size_t count, ForwardIterator result);	
	
	<i>Effects:</i>
		for ( ; count&gt;0; ++result, ++first, --count)
			::new (static_cast&lt;void*&gt;(addressof(*result)))
				typename iterator_traits&lt;ForwardIterator&gt;::value_type(std::move(*first));
		return result;
	
	template&lt;class ForwardIterator&gt;
	FwdIt uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
	
	<i>Effects:</i>
		for (; first != last; ++first)
			::new (static_cast&lt;void*&gt;(addressof(*first)))
				typename iterator_traits&lt;ForwardIterator&gt;::value_type();
		return first;
	
	template&lt;class ForwardIterator&gt;
	FwdIt uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
	
	<i>Effects:</i>
		for (; first != last; ++first)
			::new (static_cast&lt;void*&gt;(addressof(*first)))
				typename iterator_traits&lt;ForwardIterator&gt;::value_type;
		return first;
	
</code></pre></blockquote>

</BODY></HTML>