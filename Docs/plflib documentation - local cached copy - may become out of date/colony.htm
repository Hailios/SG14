<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="description" content="PLF C++ Library - plf::colony">
  <meta name="keywords"
  content="C++, C, vector, colony, plf::colony, speed, OO, containers, optimize, performance, pointer, iterator, invalidation, benchmarks, results, benchmark, vs, versus, std::list, std::map, std::multiset, std::vector, std::deque, deque, segmented_tree">
  <title>PLF C++ Library - plf::colony</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<a href="index.htm">Home</a>

<h1>PLF C++ Library - plf::colony</h1>
<ul>
  <li><a href="#intro">Intro</a></li>
  <li><a href="#details">Implementation</a></li>
  <li><a href="#license">License</a></li>
  <li><a href="#download">Download</a></li>
  <li><a href="#functions">Function Descriptions and Syntax</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#faq">Frequently-asked Questions</a></li>
  <li><a href="#version">Version History</a></li>
  <li><a href="#contact">Contact</a></li>
</ul>

<h2><a id="intro"></a>Introduction</h2>

<p>A colony is a C++ template-based unordered data container which provides
better performance than other std:: library containers when:</p>
<ol type="a">
  <li>Insertions and erasures to the container are occuring frequently in
    realtime ie. in performance-critical code, <i><b>and/or</b></i> </li>
  <li>Pointers which point to non-erased container elements must not be
    invalidated by insertion or erasure.</li>
</ol>

<p>While the benchmarks in the section below are a better area to get a feel
for the performance benefits, the general speed characteristics are:</p>
<ul>
  <li><i>Insertion</i>: better than any std:: library container except good
    implementations of deque.</li>
  <li><i>Erasure</i>: better than any std:: library container.</li>
  <li><i>Iteration</i>: better than any std:: library container where pointer
    validity to non-erased elements is important. Where pointer validity is
    unimportant, better than any std:: library container except deque and
    vector.</li>
</ul>

<p>As explored further in the benchmarks there are some <a
href="#comparative_tests">vector/deque modifications</a> which can outperform
colony during iteration while maintaining pointer validity, but at a cost to
usability and memory usage. Colony's other advantages include the freeing and
recycling of unused memory on-the-fly, the guaranteed stability of
pointers/references/iterators to non-erased elements (which makes programming
with containers of inter-related data structures faster and much easier), and
broad cross-compiler support.</p>

<p>It can be reasonably compared to a "bag" or "bucket-array" styled structure,
where each element location can be emptied and skipped over. Unlike a bucket
array it does not use keys, iterates faster due to the use of a <a
href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting
skipfield</a> instead of a boolean field, and frees or recycles unused memory
from erased element locations on the fly. As it was initially developed
predominantly for game development, colony favours small and large struct/class
performance over scalar-type (float, int, etc) performance.</p>

<h2><a id="motivation"></a>Motivation</h2>

<p>When working on video game engines we are predominantly dealing with
collections of data where:<br>
(<i>Note: These requirements match other areas of software development as well,
but to simplify discussion I will focus on video game development</i>)</p>
<ol type="a">
  <li>Elements within data collections refer to elements within other data
    collections (through a variety of methods - indices, pointers, etc). An
    example is a game entity referring to both a texture object and collision
    blocks, as well as sound data. These references must stay valid throughout
    the course of the game/level. For this reason, any container (or use of a
    container) which causes pointer or index invalidation can create
    difficulties or necessitate workarounds.</li>
  <li>Order is unimportant for the most part. The majority of data collections
    are simply iterated over, transformed, referred to and utilized with no
    regard to order.</li>
  <li>Storage of small-to-medium-sized classes and structs is the norm. Work
    with collections of small scalar types like int, double is far less common.
    Sometimes data can be stored in a SoA (Struct of Arrays) configuration, but
    these cases are somewhat less common.</li>
  <li>Erasing or otherwise removing or deactivating objects occurs frequently
    in-game and in realtime (though often erasures will be implemented to occur
    at the end of a frame due to multithreading concerns). An example could be
    destroying a wall, or a game enemy. For this reason methods of erasure
    which create strong performance penalties are avoided.</li>
  <li>Creating new objects and adding them into the gameworld on-the-fly is
    also common - for example, a tree which drops leaves every so often, or a
    quadtree.</li>
  <li>We don't always know in advance how many elements there will be in a
    container at the beginning of development, or even at the beginning of a
    level during playback - an example of this being a MMORPG (massively
    multiplayer online role-playing game). In a MMORPG the number of game
    entities fluctuates based on how many players are playing, though there may
    be maximum capacity limits. Genericized game engines in particular have to
    adapt to considerably different user requirements and scopes. For this
    reason extensible containers which can expand and contract in realtime are
    usually necessary.</li>
  <li>Depending on the complexity and scope of any given game, we can be
    dealing with anywhere between 10 and 100000 objects in a given area. We are
    not typically dealing with the types of capacities necessitated by
    large-scale mathematical or statistical applications.</li>
  <li>For performance reasons, memory storage which is more-or-less contiguous
    is preferred. Lists, vectors of pointers to dynamically-allocated objects,
    and maps as implemented in the standard library are unusable.</li>
  <li>Memory wastage is avoided, and in particular, any container which allocates upon initialisation tends to be avoided as this can incur purposeless memory and performance costs.</li>
</ol>
<br>


<p>To meet these requirements, game developers tend to either (a) develop their
own custom containers for given scenario or (b) develop workarounds for the
failings of std::vector. These workarounds are many and varied, but the most
common are probably:</p>
<ol>
  <li>Using a boolean flag (or similar) to indicate the inactivity of an object
    (as opposed to actually erasing from the vector). When erasing, one simply
    adjusts the boolean flag, and when iterating, items with the adjusted
    boolean flag are skipped. External elements refer to elements within the
    container via indexes rather than pointers (which can be invalidated upon
    insertion).
    <p>Advantages: Fast erasure.</p>
    <p>Disadvantages: Slow to iterate due to branching.</p>
  </li>
  <li>Utilizing a vector of data with a secondary vector of indexes. When
    erasing, the erasure occurs in the vector of indexes, not the vector of
    data, and when iterating, one iterates over the vector of indexes, then
    accessing the data from the vector of data via the index.
    <p>Advantages: Faster iteration.</p>
    <p>Disadvantages: Erasure still incurs some reallocation cost, can increase
    jitter.</p>
  </li>
  <li>Combining a swap-and-pop mechanism with some form of dereferenced lookup
    system to enable contiguous element iteration (known as a <a
    href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">'packed array'</a>,
    or various other names). In this case when erasing we swap the back element from the
    vector of elements with the element being erased, then pop the (swapped)
    back element. We keep a stable vector of indexes (or similar) and update the
    index numbers corresponding with the element being erased and the element
    being moved. In this case external objects referring to elements within the
    container must store a pointer to the index for the element in question.
    There are many slightly varied alternatives to this method.
    This method is more useful when the container's data is mostly being
    iterated over with fewer references to the individual elements from outside
    objects.
    <p>Advantages: Iteration is at standard vector speed.</p>
    <p>Disadvantages: Erase could be slow if objects are large and swap cost is
    therefore large. All references to elements incur additional costs.</p>
  </li>
</ol>
<br>


<p>All three techniques have the disadvantage of slow singular insertions, and
the first two will also continually expand memory usage when erasing and
inserting over periods of time. The third deals better with this scenario as it
swaps from the back rather than leaving gaps in the elements vector, however will suffer in performance if elements within the container are heavily referred to by external objects/elements.</p>

<p>Colony is an attempt to bring a more generic solution to this domain. It has
the advantage of good iteration speed while maintaining a similar erasure speed
to the boolean technique described above, and without causing pointer
invalidation upon either erasure or insertion. It's insertion speed is also
much faster than a vector's. Memory from erased elements is either reused by
subsequent insertions or released to the OS on-the-fly. It achieves these ends
by via a number of new approaches: a <a href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting skipfield</a> (instead of a boolean field), a <a
href="chained_group_allocation_pattern.htm">linked chain</a> of
increasingly-large memory blocks (instead of a singular memory block or vector
of blocks), and a custom internal reduced stack (based on <a
href="stack.htm">plf::stack</a>) to enable erased memory location re-use.</p>

<p>More data on the performance characteristics of the colony versus other
containers and workarounds can be found in the <a href="#benchmarks">benchmarks
section</a>, read below to gain an understanding of the mechanics.</p>

<h2><a id="details"></a>Implementation</h2>

<p>plf::colony uses a <a
href="chained_group_allocation_pattern.htm">chained-group memory allocation
pattern</a> with a growth factor of 2, (doubly-linked chains of element
"groups" containing memory blocks with additional structure metadata, including
in this case per-memory-block jump-counting skipfields). A growth factor of 2
tends gives the best performance in a majority of scenarios (hence why it is
used for the majority of vector implementations). Colony's minimum and maximum
memory block sizes can also be adjusted to suit individual use-cases. Using a
multiple-memory-block approach removes the necessity for data reallocation upon
insertion, and because data is not reallocated, all
references/pointers/iterators to container elements stay valid
post-insertion.</p>

<p>Due to a std::vector being the most widely-used and commonly-understood of
the std:: library containers, we here contrast the storage mechanisms of a
colony with that of a vector:</p>
<img src="vector_addition.gif"
alt="Visual demonstration of inserting to a full vector" height="540"
width="960"> <img src="colony_addition.gif"
alt="Visual demonstration of inserting to a full colony" height="540"
width="960"> 

<p>The lack of reallocation is also why insertion into a colony is faster than
insertion into a std::vector. Now we look at erasure. When an element is erased
in a std::vector, the following happens:</p>

<p><img src="vector_erasure.gif"
alt="Visual demonstration of randomly erasing from a vector" height="540"
width="960"> </p>

<p>When an element is erased in a colony, this happens:</p>
<img src="colony_erasure.gif"
alt="Visual demonstration of randomly erasing from a colony" height="540"
width="960"> 

<p>This is why a colony has a performance advantage over std::vector when
erasing. </p>

<p>Upon subsequent insertions to a colony post-erasure, colony will check to
see if it's erased-location stack is empty. If it is empty, it inserts to the
end of the colony, creating a new group if the last group is full. If it is not
empty, it pops an erased element location off the stack and reuses that memory
address for the newly-inserted element. If you erase all elements in any given
group in a colony, the group is removed from the colony's chain and released to
the OS - at that point any erased element locations present in the
erased-location stack are also removed.</p>

<h2><a id="license" name="license"></a>License</h2>

<p>plf::colony is under a permissive <a
href="http://en.wikipedia.org/wiki/Zlib_License">zlib license</a>. This means:
Software is used on 'as-is' basis. It can be modified and used in commercial
software. Authors are not liable for any damages arising from its use. The
distribution of a modified version of the software is subject to the following
restrictions:</p>
<ul>
  <li>The authorship of the original software must not be misrepresented,</li>
  <li>Altered source versions must not be misrepresented as being the original
    software, and</li>
  <li>The license notice must not be removed from source distributions.</li>
</ul>

<h2><a id="download"></a>Download</h2>

<p>Download <a href="plf_colony_14-10-2016.zip">here</a> (26kb zip file) or
view the <a
href="https://github.com/mattreecebentley/plf_colony">repository</a><br>
<br>
The colony library is a simple .h header file, to be included with a #include
command. The package includes the plf::stack .h file, which is used internally
by plf::colony.<br>
<br>
In addition if you are interested in benchmarking you can also download the <a
href="plf_benchmark_suite_03-10-2016.zip">plf benchmark suite</a> (36kb zip
file), which includes plf::nanotimer.</p>

<h2><a id="functions"></a>Function Descriptions and syntax</h2>

<p>Colony meets the requirements of the C++ <a
href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a
href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>,
and <a
href="http://en.cppreference.com/w/cpp/concept/ReversibleContainer">ReversibleContainer</a>
concepts.</p>

<p>For the most part the syntax and semantics of colony functions are very
similar to all std:: c++ libraries. Formal description is as follows:</p>
<code>template &lt;class T, class Allocator = std::allocator&lt;T&gt;, typename
Skipfield_Type = unsigned short&gt; class colony</code> 

<p><code><b>T</b></code> - the element type. In general T must meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>, <a
href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>
and <a href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a>.<br>
However, if emplace is utilized to insert elements
into the colony, and no functions which involve copying or moving are utilized, T is only required to meet the requirements of <a href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>.<br>
If move-insert is utilized instead of emplace, T must also meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a>
.<br>
<br>
<code><b>Allocator</b></code> - an allocator that is used to acquire memory to
store the elements. The type must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Allocator">Allocator</a>. The
behavior is undefined if <code>Allocator::value_type</code> is not the same as
T.<br>
<br>
<code><b>Skipfield_Type</b></code> - an unsigned integer type. This type is
used to create the skipfield and the maximum size of element memory blocks is
constrained by it's bit-depth due to the nature of a jump-counting skipfield.
For example, <code>unsigned short</code> on most platforms is 16-bit and
therefore constrains the size of individual memory blocks to a maximum of 65535
elements. <code>unsigned short</code> has been found to be the optimal type for
performance based on benchmarking. However there may be some memory-constrained
situations where element block allocations of more than 255 elements at a time
would not be desirable. In these situations, <code>unsigned char</code> may be
used for the skipfield instead, resulting in some additional memory usage
saving for the skipfield itself. It is unlikely for there to be any
circumstances which benefit from a skipfield bit-depth greater than
<code>unsigned short</code>. If <code>Skipfield_Type</code> is not an unsigned
integer type, behaviour is undefined. </p>

<h4>Basic example of usage</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;

  <span style="color: #888888">// Insert 100 ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    i_colony.insert(i);
  }

  <span style="color: #888888">// Erase half of them:</span>
  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Total the remaining ints:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>it;
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Example demonstrating pointer stability</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;</span> p_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;::</span>iterator p_it;

  <span style="color: #888888">// Insert 100 ints to i_colony and pointers to those ints to p_colony:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    it <span style="color: #333333">=</span> i_colony.insert(i);
    p_colony.insert(<span style="color: #333333">&amp;</span>(<span style="color: #333333">*</span>it));
  }

  <span style="color: #888888">// Erase half of the ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Erase half of the int pointers:</span>
  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    p_it <span style="color: #333333">=</span> p_colony.erase(p_it);
  }

  <span style="color: #888888">// Total the remaining ints via the pointer colony (pointers will still be valid even after insertions and erasures):</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>(<span style="color: #333333">*</span>p_it);
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  
  <span style="color: #008800; font-weight: bold">if</span> (total <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2500</span>)
  {
    std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Pointers still valid!"</span> <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  }
  
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Iterator Invalidation</h4>

<table border="1">
  <tbody>
    <tr>
      <td>All read-only operations, swap, std::swap</td>
      <td>Never</td>
    </tr>
    <tr>
      <td>clear, reinitialize, operator = </td>
      <td>Always</td>
    </tr>
    <tr>
      <td>reserve, shrink_to_fit</td>
      <td>Only if capacity is changed</td>
    </tr>
    <tr>
      <td>change_group_sizes, change_minimum_group_size, change_maximum_group_size</td>
      <td>Only if supplied minimum group size is larger than smallest group in colony, or supplied maximum group size is smaller than largest group in colony.</td>
    </tr>
    <tr>
      <td>erase</td>
      <td>Only for the erased element</td>
    </tr>
    <tr>
      <td>insert, emplace</td>
      <td>If an iterator is == end() it may be invalidated by a subsequent
        insert/emplace in some cases. Otherwise no.</td>
    </tr>
  </tbody>
</table>

<h4>Member types</h4>

<table border="1">
  <tbody>
    <tr>
      <td><b>Member type</b></td>
      <td><b>Definition</b></td>
    </tr>
    <tr>
      <td><code>value_type</code></td>
      <td><code>T</code></td>
    </tr>
    <tr>
      <td><code>allocator_type</code></td>
      <td><code>Allocator</code></td>
    </tr>
    <tr>
      <td><code>size_type</code></td>
      <td><code>Allocator::size_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::size_type
      (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>difference_type</code></td>
      <td><code>Allocator::difference_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::difference_type
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>reference</code></td>
      <td><code>Allocator::reference (pre-c++11)<br>
        value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_reference</code></td>
      <td><code>Allocator::const_reference (pre-c++11)<br>
        const value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>pointer</code></td>
      <td><code>Allocator::pointer (pre-c++11)<br>
        value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_pointer</code></td>
      <td><code>Allocator::const_pointer (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::const_pointer
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>reverse_iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_reverse_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
  </tbody>
</table>

<h3>Constructors</h3>

<table border="1">
  <tbody>
    <tr>
      <td>default</td>
      <td><code>explicit colony(const allocator_type &amp;alloc =
        allocator_type())</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>explicit colony(const size_type n, const unsigned short
        min_group_size = 8, const unsigned short max_group_size = USHRT_MAX,
        const allocator_type &amp;alloc = allocator_type())<br>
        explicit colony(const size_type n, const value_type &amp;element, const
        unsigned short min_group_size = 8, const unsigned short max_group_size
        = USHRT_MAX, const allocator_type &amp;alloc = allocator_type())
      </code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template&lt;typename InputIterator&gt; colony(const
        InputIterator &amp;first, const InputIterator &amp;last, const unsigned
        short min_group_size = 8, const unsigned short max_group_size =
        USHRT_MAX, const allocator_type &amp;alloc = allocator_type())<br>
        </code></td>
    </tr>
    <tr>
      <td>copy</td>
      <td><code>colony(const colony &amp;source)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>colony(colony &amp;&amp;source) noexcept <font size="2">(C++11
        and upwards)</font></code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>colony(const std::initializer_list&lt;value_type&gt;
        &amp;element_list, const unsigned short min_group_size = 8, const
        unsigned short max_group_size = USHRT_MAX, const allocator_type
        &amp;alloc = allocator_type()) </code></td>
    </tr>
  </tbody>
</table>

<h4>Some constructor usage examples</h4>
<ul>
  <li><code>colony&lt;T&gt; a_colony</code> 
    <p>Default constructor - default minimum group size is 8, default maximum
    group size is USHRT_MAX (typically 65535). You cannot set the group sizes
    from the constructor in this scenario, but you can call the
    change_group_sizes() member function after construction has occurred.<br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony;</code> </p>
  </li>
  <li><code>colony&lt;T, the_allocator&lt;T&gt; &gt; a_colony(const
    allocator_type &amp;alloc = allocator_type())</code>
    <p>Default constructor, but using a custom memory allocator eg. something
    other than std::allocator.<br>
    Example: <code style="color: brown">plf::colony&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_colony;</code><br>
    Example2:<br>
    <code style="color: brown">// Using an instance of an allocator as well as
    it's type<br>
    tbb::allocator&lt;int&gt; alloc_instance;<br>
    plf::colony&lt;int, tbb::allocator&lt;int&gt; &gt;
    int_colony(alloc_instance);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; colony(const size_type n, const unsigned short
    min_group_size = 8, const unsigned short max_group_size = USHRT_MAX)</code> 
    <p>Fill constructor with value_type unspecified, so the value_type's
    default constructor is used. <code>n</code> specifies the number of
    elements to create upon construction. If <code>n</code> is larger than
    <code>min_group_size</code>, the size of the groups created will either be
    <code>n</code> and <code>max_group_size</code>, depending on which is
    smaller. <code>min_group_size</code> (ie. the smallest possible number of
    elements which can be stored in a colony group) can be defined, as can the
    <code>max_group_size</code>. Setting the group sizes can be a performance
    advantage if you know in advance roughly how many objects are likely to be
    stored in your colony long-term - or at least the rough scale of storage.
    If that case, using this can stop many small initial groups being
    allocated. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony(62);</code></p>
  </li>
  <li><code>colony&lt;T&gt; colony(const
    std::initializer_list&lt;value_type&gt; &amp;element_list, const unsigned
    short min_group_size = 8, const unsigned short max_group_size =
    USHRT_MAX)</code> 
    <p>Using an initialiser list to insert into the colony upon
    construction.<br>
    Example: <code style="color: brown">std::initializer_list&lt;int&gt;
    &amp;el = {3, 5, 2, 1000};<br>
    plf::colony&lt;int&gt; int_colony(el, 64, 512);</code></p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const colony &amp;source)</code> 
    <p>Copy all contents from source colony, removes any empty (erased) element
    locations in the process. Size of groups created is either the total size
    of the source colony, or the maximum group size of the source colony,
    whichever is the smaller. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(int_colony_1);</code></p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(colony &amp;&amp;source)</code> 
    <p>Move all contents from source colony, does not remove any erased element
    locations or alter any of the source group sizes. Source colony is now void
    of contents and can be safely destructed. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt; int_colony_1(50,
    5, 512, 512); // Create colony with min and max group sizes set at 512
    elements. Fill with 50 instances of int = 5.<br>
    plf::colony&lt;int&gt; int_colony_2(std::move(int_colony_1)); // Move all
    data to int_colony_2. All of the above characteristics are now applied to
    int_colony2.</code></p>
  </li>
</ul>

<h3>Iterators</h3>

<p>All iterators are bidirectional but also provide &gt;, &lt;, &gt;= and &lt;=
for convenience (for example, in for loops). Functions for iterator,
reverse_iterator, const_iterator and const_reverse_iterator follow:</p>

<p><code>operator *<br>
operator -&gt;<br>
operator ++<br>
operator --<br>
operator =<br>
operator ==<br>
operator !=<br>
operator &lt;<br>
operator &gt;<br>
operator &lt;=<br>
operator &gt;=<br>
base() (reverse_iterator and const_reverse_iterator only)</code> </p>

<p>All operators have O(1) amortised time-complexity. Originally there were +=,
-=, + and - operators, however the time complexity of these varied from O(n) to
O(1) depending on the underlying state of the colony, averaging in at O(log n).
As such they were not includable in the iterator functions (as per C++
standards). These have been transplanted to colony's advance(), next(), prev()
and distance() member functions. Greater-than/lesser-than operator usage
indicates whether an iterator is higher/lower in position compared to another
iterator in the same colony (ie. closer to the end/beginning of the colony).</p>

<h3>Member functions</h3>

<h4>Insert</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator insert (const value_type &amp;val)</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>iterator insert (const size_type n, const value_type
        &amp;val)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template &lt;class InputIterator&gt; iterator insert (const
        InputIterator &amp;first, const InputIterator &amp;last)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>iterator insert (value_type&amp;&amp; val) <font
        size="2">(C++11 and upwards)</font></code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>iterator insert (const std::initializer_list&lt;value_type&gt;
        &amp;il)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator insert(const value_type &amp;element)</code> 
    <p>Inserts the element supplied to the colony, using the object's
    copy-constructor. Will insert the element into a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(23);</code> </li>
  <li><code>iterator insert (const size_type n, const value_type
    &amp;val)</code> 
    <p>Inserts <code>n</code> copies of <code>val</code> into the colony. Will
    insert the element into a previously erased element slot if one exists,
    otherwise will insert to back of colony. Returns iterator to location of
    first inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(10, 3);</code> </li>
  <li><code>template &lt;class InputIterator&gt; iterator insert (const
    InputIterator &amp;first, const InputIterator &amp;last)</code> 
    <p>Inserts a series of <code>value_type</code> elements from an external
    source into a colony holding the same <code>value_type</code> (eg. int,
    float, a particular class, etcetera). Stops inserting once it reaches
    <code>last</code>. Example:</p>
    <code style="color: brown">// Insert all contents of colony2 into
    colony1:<br>
    colony1.insert(colony2.begin(), colony2.end());</code> </li>
  <li><code>iterator insert(value_type &amp;&amp;element) <b>C++11 and
    upwards</b></code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::string string1 = "Some text";<br>
    <br>
    plf::colony&lt;std::string&gt; data_colony;<br>
    data_colony.insert(std::move(string1));</code></p>
  </li>
  <li><code>iterator insert (const std::initializer_list&lt;value_type&gt;
    &amp;il)</code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::initializer_list&lt;int&gt; some_ints =
    {4, 3, 2, 5};<br>
    <br>
    plf::colony&lt;int&gt; i_colony;<br>
    i_colony.insert(some_ints);</code></p>
  </li>
</ul>

<h4>Erase</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator erase(const iterator &amp;it)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>void erase(const iterator &amp;first, const iterator
        &amp;last)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator erase(const iterator &amp;it)</code>
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Returns an iterator pointing to the next non-erased element in the
    colony (or to end() if no more elements are available). This must return an
    iterator because if a colony group becomes entirely empty, it will be
    removed from the colony, invalidating the existing iterator. Attempting to
    erase a previously-erased element results in undefined behaviour (this is
    checked for via an assert in debug mode). Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.insert(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const iterator &amp;first, const iterator
    &amp;last)</code> 
    <p>Erases all contents of a given colony from <code>first</code> to the
    element before the <code>last</code> iterator. Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin();<br>
    colony1.advance(iterator1, 10);<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin();<br>
    colony1.advance(iterator2, 20);<br>
    colony1.erase(iterator1, iterator2);</code> </li>
</ul>

<h4>Other functions</h4>
<ul>
  <li><code>iterator emplace(Arguments ...parameters) <b>C++11 and
    upwards</b></code> 
    <p>Constructs new element directly within colony. Will insert the element
    in a previously erased element slot if one exists, otherwise will insert to
    back of colony. Returns iterator to location of inserted element.
    "...parameters" are whatever parameters are required by the object's
    constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
     int number;<br>
    public:<br>
     simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns a boolean indicating whether the colony is currently empty of
    elements.<br>
    Example: <code style="color: brown">if (object_colony.empty())
    return;</code></p>
  </li>
  <li><code>size_type size()</code> 
    <p>Returns total number of elements currently stored in container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type max_size()</code> 
    <p>Returns the maximum number of elements that the allocator can store in
    the container. This is an approximation as it does attempt to measure the
    memory overhead of the container's internal memory structures. It is not
    possible to measure the latter because a copy operation may change the
    number of groups utilized for the same amount of elements, if the maximum
    or minimum group sizes are different in the source container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.max_size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type capacity()</code>
    <p>Returns total number of elements currently able to be stored in
    container without expansion.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.capacity()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>void shrink_to_fit()</code> 
    <p>Reduces container capacity to the amount necessary to store all
    currently stored elements. If the total number of elements is larger than
    the maximum group size, the resultant capacity will be equal to
    <code>((total_elements / max_group_size) + 1) * max_group_size</code>
    (rounding down at division). Invalidates all pointers, iterators and
    references to elements within the container.<br>
    Example: <code style="color: brown">i_colony.shrink_to_fit();</code></p>
  </li>
  <li><code>void reserve(unsigned short reserve_amount)</code> 
    <p>Preallocates memory space sufficient to store the number of elements
    indicated by <code>reserve_amount</code>. The maximum size for this number
    is limited to the maximum group size of the colony and will be truncated if
    necessary. The default maximum group size is 65535 on the majority of
    platforms.<br>
    Example: <code style="color: brown">i_colony.reserve(15);</code></p>
  </li>
  <li><code>void clear()</code>
    <p>Empties the colony and removes all elements and groups.<br>
    Example: <code style="color: brown">object_colony.clear();</code></p>
  </li>
  <li><code>void change_group_sizes(const unsigned short min_group_size, const
    unsigned short max_group_size)</code>
    <p>Changes the minimum and maximum internal group sizes, in terms of number
    of elements stored per group. If the colony is not empty and either min_group_size is larger than the smallest group in the colony, or max_group_size is smaller than the largest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new group sizes, invalidating all pointers/iterators/references.<br>
    Example: <code style="color: brown">object_colony.change_group_sizes(1000,
    10000);</code></p>
  </li>
  <li><code>void change_minimum_group_size(const unsigned short
    min_group_size)</code>
    <p>Changes the minimum internal group size only, in terms of minimum number
    of elements stored per group. If the colony is not empty and min_group_size is larger than the smallest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new minimum group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_minimum_group_size(100);</code></p>
  </li>
  <li><code>void change_maximum_group_size(const unsigned short
    min_group_size)</code>
    <p>Changes the maximum internal group size only, in terms of maximum number
    of elements stored per group. If the colony is not empty and either max_group_size is smaller than the largest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new maximum group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_maximum_group_size(1000);</code></p>
  </li>
  <li><code>void reinitialize(const unsigned short min_group_size, const
    unsigned short max_group_size)</code>
    <p>Semantics of function are the same as "clear(); change_group_sizes(min_group_size, max_group_size);", but without the copy-construction code of the change_group_sizes() function - this means it can be used with element types which are non-copy-constructible, unlike change_group_sizes().<br>
    Example: <code style="color: brown">object_colony.reinitialize(1000,
    10000);</code></p>
  </li>
  <li><code>void swap(colony &amp;source)</code>
    <p>Swaps the colony's contents with that of <code>source</code>.<br>
    Example: <code
    style="color: brown">object_colony.swap(other_colony);</code></p>
  </li>
  <li><code>friend void swap(colony &amp;A, source &amp;B)</code>
    <p>External friend function, swaps the colony A's contents with that of
    colony B (assumes both stacks have same element type).<br>
    Example: <code style="color: brown">swap(object_colony,
    other_colony);</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;source)</code> 
    <p>Copy the elements from another colony to this colony, clearing this
    colony of existing elements first.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++03<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;&amp;source) <b>C++11
    only</b></code> 
    <p>Move the elements from another colony to this colony, clearing this
    colony of existing elements first. Source colony becomes invalid but can be
    safely destructed without undefined behaviour.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code></p>
  </li>
  <li><code>bool operator == (const colony &amp;source)</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are equal.<br>
    Example: <code style="color: brown">if (object_colony == object_colony2)
    return;</code></p>
  </li>
  <li><code>bool operator != (const colony &amp;source)</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are not equal.<br>
    Example: <code style="color: brown">if (object_colony != object_colony2)
    return;</code></p>
  </li>
  <li><code>iterator begin(), iterator end(), const_iterator cbegin(),
    const_iterator cend()</code>
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony (as per standard STL
    guidelines).</p>
  </li>
  <li><code>reverse_iterator rbegin(), reverse_iterator rend(),
    const_reverse_iterator cbegin(), const_reverse_iterator cend()</code>
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony (as
    per standard STL guidelines).</p>
  </li>
  <li><code>iterator get_iterator_from_pointer(const element_pointer_type the_pointer) <b>(slow)</b></code>
    <p>Getting a pointer from an iterator is simple - simply dereference it then grab the address ie. <code>"&(*the_iterator);"</code>.
    Getting an iterator from a pointer is typically not so simple. This function enables the user to do exactly that.
    This is expected to be useful in the use-case where external
    containers are storing pointers to colony elements instead of iterators (as
    iterators have 3 times the size of an element pointer) and the program
    wants to erase the element being pointed to or possibly change the element being pointed to.
	 Converting a pointer to an iterator using this method and then erasing, is about 20%
    slower on average than erasing when you already have the iterator. This is less dramatic than it sounds, as it is still faster than all std:: container erasure times except std::list, which it is roughly equal
    to. However this is generally a slower, lookup-based operation.
	If the lookup doesn't find a non-erased element based on that pointer, it returns <code>end()</code>. Otherwise it returns an iterator pointing to the element in question. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    a_struct *struct_pointer = &amp;(*an_iterator);<br>
	iterator another_iterator = data_colony.get_iterator_from_pointer(struct_pointer);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_iterator(const iterator/const_iterator &amp;the_iterator) <b>(slow)</b></code>
    <p>While colony is a container with unordered insertion (and is therefore unordered), it still has a (transitory) order which changes frequently upon erasure and insertion. <i>Temporary</i> index numbers are therefore obtainable. These can be useful, for example, when creating a save file in a computer game, where certain elements in a container may need to be re-linked to other elements in other container upon reloading the save file. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    unsigned int index = data_colony.get_index_from_iterator(an_iterator);<br>
    if (index == 2) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_reverse_iterator(const reverse_iterator/const_reverse_iterator &amp;the_iterator) <b>(slow)</b></code>
    <p>The same as get_index_from_iterator, but for reverse_iterators and const_reverse_iterators. Index is from front of colony (same as iterator), not back of colony. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::reverse_iterator r_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    r_iterator = data_colony.rend();<br>
    unsigned int index = data_colony.get_index_from_reverse_iterator(r_iterator);<br>
    if (index == 1) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>iterator get_iterator_from_index(const size_type index) <b>(slow)</b></code>
    <p>As described above, there may be situations where obtaining iterators to specific elements based on an index can be useful, for example, when reloading save files. This function is basically a shorthand to avoid typing <code>"iterator it = colony.begin(); colony.advance(it, 50);"</code>. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    iterator an_iterator = data_colony.insert(struct_instance);<br>
    iterator another_iterator = data_colony.get_iterator_from_index(2);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>


</ul>
<!-- <h3>Non-member functions</h3> -->
<ul>
  <li><code>template &lt;iterator_type&gt; void advance(iterator_type iterator,
    distance_type distance)</code>
    <p>Increments/decrements the iterator supplied by the positive or negative
    amount indicated by <i>distance</i>. Speed of incrementation will almost
    always be faster than using the ++ operator on the iterator for increments
    greater than 1. In some cases it may approximate O(1). The iterator_type
    can be an iterator, const_iterator, reverse_iterator or
    const_reverse_iterator.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.begin();<br>
    i_colony.advance(it, 20); </code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type next(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then increments/decrements this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type prev(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then decrements/increments this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it2 =
    i_colony.prev(i_colony.end(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; difference_type distance(const
    iterator_type &amp;first, const iterator_type &amp;last)</code> 
    <p>Measures the distance between two iterators, returning the result, which
    will be negative if the second iterator supplied is before the first
    iterator supplied in terms of it's location in the colony.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);<br>
    colony&lt;int&gt;::iterator it2 = i_colony.prev(i_colony.end(), 20);<br>
    std::cout "Distance: " i_colony.distance(it, it2) std::endl;</code></p>
  </li>
</ul>

<h2><a id="benchmarks"></a>Benchmarks (out-of-date as of Sept 2016)</h2>

<p style="font-size: 75%"><i>Last updated 16-04-2016 v3.04</i></p>

<p>The test setup is an E8500 on an Intel motherboard, 8GB ram, running GCC 5.1
x64 as compiler. Build settings are
"-O2;-march=native;-std=c++11;-fomit-frame-pointer". Results for Visual Studio
2013 can be found <a href="colony_benchmark_msvc_results.htm">here</a>. Tests
are based on a sliding scale of number of runs vs number of elements, so a test
with only 10 elements in a container may average 100000 runs, whereas a test
with 100000 elements may only average 10 runs. This tends to give adequate
results without overly lengthening test times. I have not included results
involving 'reserve()' functions as the differences to overall insertion
performance were not adequate. The source code can be found in the <a
href="#download">downloads</a> section above.</p>

<h4>Overall tests design</h4>

<p><b>Insertion:</b> is into empty containers (with the exception of one
clearly-labeled re-insertion test toward the end), entering single elements at
a time. This matches the use case of colony, where insertion on-the-fly is
expected.<br>
<b>Erasure:</b> initially takes place in an iterative fashion for the raw
tests, erasing elements at random as we iterate through the container. This
does not fit best use case for std::deque or std::vector, which would usually
take the form of a remove_if pattern, but that pattern makes no performance
difference to colony, and the raw tests are primarily looking for good
candidates to compare versus colony. In the comparative and modification tests
vector/deque comparisons with remove_if erasures are included.<br>
<b>Iteration:</b> is straightforward iteration from the start to end of any
containers. Typically there are more runs for iteration than the other tests
due to them being a much quicker procedure, so more data delivers a more stable
average.</p>

<h3>Raw performance tests</h3>

<p>Before we begin measuring colony against equivalent containers (or modified
containers) ie. ones which do not invalidate pointers on erasure or insertion,
we need to identify which containers are good candidates for comparison based
on raw testing without regard to pointer/iteration invalidation. With that in
mind the following tests compares colony against the typical standard library
containers, and boost::segmented_tree, a current boost candidate. Tests are
carried out on the following types: (a) a 8-bit type ie. char, (b) a 32-bit
type ie. int, (c) a 64-bit type ie. double, (d) a small struct containing two
pointers and four scalar types, and (e) a large struct containing 2 pointers, 4
scalar types, a large array of ints and a small array of chars.</p>

<p>The first test measures time to insert N elements into a given container,
the second measures the time taken to erase 25% of those same elements from the
container, and the third test measures iteration performance after the second
test has taken place. Both linear and logarithmic views of each benchmark are
provided in order to better show the performance of lower element amounts.</p>

<h4>Insertion Performance</h4>

<p><i>Note: because plf::colony is an unordered container and subsequently we
are not concerned about insert order, push_front has been used with std::list
instead of push_back, in order to provide a fair performance comparison.</i></p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/char_insertion_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_insertion.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_insertion_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_insertion_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_insertion.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_insertion_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_insertion.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_insertion_log.png"><br>


<p>A predictable pattern for all but the large struct test is shown for
insertion:<br>
std::deque dominates insertion, with plf::colony equal after about 100
elements, but then for large structs it's performance completely eclipses
std::deque. std::vector is nearly on a par with std::deque for very small
element types with element numbers greater than a thousand, but becomes worse
and worse the larger the size of the stored type is, and the fewer number of
stored elements there are.<br>
segmented_tree is generally slightly worse than plf::colony for small scalar
types but is significantly worse for larger types - structs and classes.
std::list, std::map and std::multiset all perform poorly by contrast, but with
large structs the situation is almost reversed, with std::list and std::map
outperforming all other contendors except for plf::colony.</p>

<p>Overall, plf::colony and std::deque dominate, with segmented_tree taking
third place and std::list/std::map getting honourable mentions for large struct
performance.</p>

<h4>Erase Performance</h4>

<p>Here we forward-iterate over each container and erase 25% of all elements
randomly. Although typical tests for erasure speed tend to simply select
element indexes within a container randomly and erase those elements in a
non-linear sequence, this does not match real-world usage for game development.
Typically in game development data is processed sequentially for performance
reasons, and any elements that need to be removed/deactivated are done so
during this iteration, or subsequently in a post-iteration cull depending on
implementation. Similarly, reverse-iteration (which would enhance vector
erasure performance for example) is not common for cache performance reasons,
but since it might be used occasionally I have given some role to it: If (due
to the variability of random number generators) 25% of all elements have no
been erased by the end of the container, the test will reverse-iterate through
the container and randomly erase the remaining necessary number of elements
until that 25% has been reached:</p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_erase_25.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/char_erase_25_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_erase_25.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_erase_25_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_erase_25.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_erase_25_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_erase_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_erase_25_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_erase_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_erase_25_log.png"><br>


<p>Across all types, plf::colony dominates performance, with std::list coming
close behind and segmented_tree in third place. std::deque and std::vector have
predictably terrible performance, as much as 100000x worse than plf::colony and
std::list for large numbers of large types.</p>

<h4>Iteration Performance</h4>

<p>Since data is typically iterated across far more than it is erased or
inserted, iteration speed is for many programs more important than erase or
insertion performance, despite the fact that it is always factors of ten faster
than either of those two.</p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_iteration.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/char_iteration_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_iteration.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_iteration_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_iteration.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_iteration_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_iteration_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_iteration_log.png"><br>


<p>For under 1000 elements, std::list is about on par with both std::deque and
std::vector, both of which dominate these tests, with std::vector taking 1st
place. However the number of elements before this effect occurs on std::list
decreases according to how large the stored type is, suggesting that
performance in this case is due to some effect of the cpu cache or
implementation. Querying the GCC mailing list about this resulted in the
following response, which I believe to be accurate due to the correlation
between std::list iteration performance and type size: "I suspect that for
working sets which fit into the first-level cache of the CPU, the simpler
iterators for std::list are faster than std::deque because the additional
memory accesses in std::list are cheaper than the fairly complicated iterator
implementation in std::deque". What this suggests is that for typical programs,
where more than one data set is competing for space in the L1 or L2 caches,
std::list performance will not follow the pattern above and generally will be
poor.</p>

<p>plf::colony performs worse than segmented_tree for scalar types, except for
char, where segmented_tree fairs very poorly, and it outperforms it for
anything larger than a scalar ie. structs and classes.</p>

<h4>Raw tests Conclusion</h4>

<p>From the above data we can see that std::list is a good contendor against
plf::colony, but only in the following scenario - where (a) the amount of data
in the container is small enough to fit entirely into the cache and (b) where
that data set is the only data set being operated on by the program in
question, and in fact the computer as a whole. That being the case, std::list
is not a general contendor, but may have a place in specialised scenarios,
though probably certainly not in game development. That aside, it has the
advantage of not requiring modification to avoid invalidation of pointers on
insertion or erasure.</p>

<p>segmented_tree overall trails behind plf::colony and invalidates
pointers/iterators on both insertion and erasure, making it a non-contendor for
the areas where we might choose to use a colony ie. where pointer/iterator
stability is required and ordered insertion is not. std::deque is a contendor,
having strong insertion performance and excellent iteration performance but
poor erasure performance - however both std::deque invalidates pointers on
erasure, meaning it requires modification to be used. std::vector is a weaker
contendor, having weak insertion performance and extremely poor erasure
performance, however it's iteration performance is always the best, even if
std::deque is very close behind. std::vector invalidates pointers on both
insertion and erasure, meaning it will require a different modification
stragety to std::deque.</p>

<h3><a name="comparative_tests"></a>Comparative performance tests</h3>

<p>So to reiterate, colony is designed for scenarios where we require good
performance while guarantee'ing pointer stability for outside elements
referring to elements within the container, and where ordered insertion is
unimportant. This describes the majority of situations when building game
engines, and possibly in other highly compartmentalised and modular
environments. The only other container, based on the raw performance tests,
which approaches this goal without modification is std::list, unfortunately as
noted this is probably only useful for a few higly specialised scenarios due to
it's iteration performance being entirely dependent on fitting all data in the
CPU cache. The other two containers which may approach usability via
modification are std::deque and std::vector.</p>

<p>Because std::deque does not invalidate pointers upon insertion to the back
or front of the container, we don't have to worry about pointers being
invalidated during non-ordered insertion, meaning we can use a specific
modification which I'lll call a pointer-to-deque deque, or pointer_deque for
short. In this scenario we take our deque of elements, and construct a
secondary deque containing pointers to each element in the first deque. When we
erase, we only erase from the pointer deque, and when we iterate, we iterate
over the pointer deque and access only those elements pointed to by the pointer
deque. In doing so we reduce erase times for larger-than-scalar types, as it is
computationally cheaper to reallocate pointers than larger structs. We also
avoid reallocation during erasure for the element deque, meaning pointers and
references to elements within the deque stay valid.</p>

<p>We cannot employ the same tactic with std::vector because of the
reallocation during insertion regardless of insertion position. What we can do
however is to employ a similar tactic using indexes instead of pointers, which
we'll call an indexed_vector. Since indexes stay valid regardless of whether
the element vector reallocates, index access to the element vector will still
work after insertion. Since we never erase from the element vector, only the
index vector, the indexes also stay valid during erasure. Index access involves
an additional step computationally to reach the desired element, so is slightly
slower during iteration than a pointer vector, but has the same advantages
during erasure. In addition outside data refering to elements within the
indexed_vector must use indexes instead of pointers to refer to the elements.
This complicates implementation as the outside data source must know which
container it is indexing, whereas a pointer approach can ignore this and simply
point to an element.</p>

<p>We will also compare the same two container modifications above using a
<i>remove_if</i> erasure pattern, adding an additional boolean field to
indicate erasure to the original stored struct type, and utilizing two passes -
the first to randomly flag elements as being ready for erasure via the boolean
field, the second using the <i>remove_if</i> pattern. This matches some use
cases in game engines where erasures are 'saved up' until the end of a given
frame, then processes. A third modified approach, which we'll call a
deque_bool, is a very common approach in a lot of game engines - a bool or
similar type is added to the original struct or class, and this type is tested
against to see whether or not the object is 'active' (true) - if inactive
(false), it is skipped over. This is somewhat similar to what a colony does,
but without the separate jump-counting skipfield which increases iteration
speed and removes the branching decisions. Again, for the purposes of this test
this is not possible with a vector of elements, as insertion would cause
invalidation of pointers to the elements.</p>

<p>Since neither the indexed_vector nor the pointer_deque will have erasure
time benefits for small scalar types, and because game development is
predominantly concerned with storage of larger-than-scalar types, we will only
test using small structs, for simplicity's sake. In addition, we will test 4
levels of erasure: 0% of all elements, 25% of all elements, 50% of all
elements, and 75% of all elements. And finally, we will test the performance of
the 75%-erased containers after re-inserting 25% of all elements back into each
container, to compare how the different models perform after reinsertion.</p>

<h4>Insertion</h4>
<img alt="test result graph" src="tests/gcc/colony/comparitive/insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/insertion_log.png"> 

<p>Here a deque_bool and plf::colony are more-or-less on a par with each other,
with both pointer_deque modifications slightly behind and std::list and
indexed_vector modifications performing poorly by comparison.</p>

<h4>Erasure</h4>

<h5>Erasing 25%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_25.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_25_log.png"> 

<h5>Erasing 50%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_50.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_50_log.png"> 

<h5>Erasing 75%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_75.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_75_log.png"> 

<p>Here the gap consistently widens between the candidates as erasure
percentage increases, with deque_bool, plf::colony and std::list being very
close to each other in 1st, 2nd and 3rd place respectively. pointer_deque and
indexed_vector have much worse performance once the number of elements climbs
above 200, 1 factor of ten above the other candidates at 2000 elements and
almost 3 factors of ten above the other candidates at 100000 elements.
pointer_deque_remove_if and indexed_vector_remove_if perform mostly the same as
colony, eclipsing colony slightly for large amounts of erasures.</p>

<h4>Iteration</h4>

<h5>Prior to erasures</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_0.png"> <img
alt="test result graph" src="tests/gcc/colony/comparitive/iteration_0_log.png"> 

<p>Here std::list is more-or-less equal to all four indexed_vector and
pointer_deque modifications for under 500 elements, then just as in the
previous tests, once less of the data fits in the cache entirely it's
performance diminishes rapidly. plf::colony and deque_bool trail behind the
other contendors.</p>

<h5>After erasing 25% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_25_log.png"> 

<p>Now we begin to see the effect of the jump-counting skipfield. std::list
does the same thing as before, but with only a quarter of the elements erased,
deque_bool's performance drops substantially and becomes worse than std::list.
plf::colony however shows only slightly worse results than pointer_deque and
indexed_vector after ~500 total elements.</p>

<h5>After erasing 50% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_50.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_50_log.png">

<p>At this point the poor iteration performance of deque_bool becomes much more
apparent.</p>

<h5>After erasing 75% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_75.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_75_log.png"> 

<p>At this point we can see that deque_bool overall performs worse than any
other contendor. Other than that it is a continuation of previously established
trends.</p>

<p>Summary: The overall pattern shows that pointer_deque and indexed_vector
modifications dominate performance with plf::colony quite close behind,
std::list performing typically and deque_bool being entirely inadequate once
erasures have occurred. The additional boolean field involved in the
<i>erasure_if</i> modifications does not appear to have an effect on
performance.</p>

<h4>Post-reinsertion iteration</h4>

<p>At this point we take the containers after the last test, at 75% erasure,
and re-insert 25% of the original number of elements, and subsequently test
iteration performance to see how reinsertion affects each container.</p>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/post_insertion_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/post_insertion_iteration_log.png"> 

<p>While plf::colony closes the gap with pointer_deque and indexed_vector
modifications, again to become roughly similar to the post-50%-erasure
iteration test, deque_bool grows worse again. This is due to the element
location recycling that is utilized in plf::colony, as opposed to deque_bool
which has no such mechanism.</p>

<h4>Scenario testing - low modification</h4>

<p>In this test we take a container, and iterate over it for 3600 cycles,
randomly erasing approximately 1 element every 120 cycles, and randomly
inserting 1 element every 120 cycles. These numbers do not correspond to the
number of elements in the container, in other words, the same number of
elements gets removed/inserted for a 10-element container as it does for a
80000-element container. By doing so we simulate a seldom-modified container (2
modifications every 2 seconds) being used by a program for 1 minute where each
cycle represents a frame, and where there are 60 frames per second. By doing so
we play off the different performance aspects of each container to approximate
an overall conclusion. Because of std::list's limitation as per the CPU cache
and competing with other potential data as mentioned earlier, and the
unlikelihood of real-world usability as a result, we've discluded it from the
tests.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_low_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_low_modification_log.png">

<p>We can see pointer_deque winning out here, followed closely by plf::colony
and indexed_vector tailing far behind. Both the <i>remove_if</i> modifications
fall in the middle, with the overhead of the additional pass obviously forming
a performance detriment for pointer_deque, and indexed_vector performing better
than indexed_vector_remove_if until around 700 elements.</p>

<h4>Scenario testing - high modification</h4>

<p>The same as the previous test, except in this test we perform 2 erasures at
random every cycle as well as 2 insertions ie. 4 modifications per frame.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_high_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_high_modification_log.png"> 

<p>Here the results are much the same but with the increased number of
modifications per frame, we see plf::colony starting to edge out pointer_deque
in terms of overall performance.</p>

<h4>Scenario testing - Very high modification</h4>

<p>In this test we change the pattern, making the number of elements
removed/inserted a percentage of the overall size of the container. In this
case we randomly erase and insert around 10% of the container size per
frame.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_very_high_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_very_high_modification_log.png"> 

<p>As could be expected, with the much higher number of erasures the
standard-erasure pointer_deque and indexed_vector fall far behind after
approximately 200 elements (though effects are still noticable at 100
elements). The <i>remove_if</i> variants perform much better, but colony
overall dominates performance.</p>

<h4>Overall conclusion</h4>

<p>We can legitimately say that if there is no competition for the CPU cache
ie. if the container in question is the only container being iterated over by
your program, then provided that your amount of data is small and will fit
entirely within the CPU cache, std::list is probably the best solution where we
(a) need adequate performance and (b) cannot have pointer invalidation and (c)
don't require ordered insertion. However this is a very small, unlikely and
specialised scenario - in the bulk of scenarios std::list should not be used
where pointer stability is required.</p>

<p>Using a bool or similar type to indicate erasure in a container (as
represented in this case by deque_bool) is always a poor choice by comparison
with the other options available, which becomes much more apparent as more and
more erasures occur, and this approach should not be used. Nor does separating
the skipfield into a separate block of memory repair the situation, as without
the jump-counting skipfield, runs of erasures tend to slow iteration speed. To
see a graph of the relative performance of plf::colony using a boolean field
instead of a jump-counting skipfield, vs a regular colony, a deque_bool and a
deque using, as an alternative, a boolean field separate to the data itself,
click <a href="skipfield_comparison.htm">here</a>.</p>

<p>pointer_deque and indexed_vector approaches both have strengths in terms of
iteration performance but their erasure performances are poor for anything
greater than 200 elements, so these two facets have to be traded off against
each other to determine overall performance. Their <i>remove_if</i> variants
are of course faster for higher numbers of erasures, but slower for small
numbers of erasures, so there's an inflexibility to either approach if one
wants optimal performance. What the use-case testing shows is that once this
and the insertion times are taken into account, the differences between these
approaches and plf::colony are minimal for lowered numbers of container
insertions/erasures, with pointer_deque having a slight lead in the case of an
efficient implementation (which GCC's implementation definitely is). Where high
numbers of erasures and insertions are involved, we can see plf::colony has
superior overall performance. In addition, while std::deque and std::vector's
erasure performance varies significantly based on the size of data and where
the element being erased is within that data, plf::colony's is predictable and
much faster, making it safer for low-latency environments.</p>

<p>plf::colony has an additional advantage which indexed_vector and
pointer_deque do not have - it reuses and releases erased element memory space.
When you erase from a indexed_vector/pointer_deque they don't release the
memory space to the OS, nor do they reuse the memory space for subsequent
insertions - meaning that with a high level of modification both containers are
perpetually expanding and never shrinking. Because gaming often occurs on
platforms with significant memory constraints this can be less-than-desirable.
And although one <i>can</i> implement a stack-based solution for recycling
erased element locations for either of these approaches based on a similar
technique to what is done in plf::colony, any reinsertions would come at a
cost, as adding the reference back into the vector of element indexes, or deque
of element pointers, would require an ordered insertion operation which results
in reallocation of subsequent pointers/indexes, meaning the insertion cost
becomes higher yet again.</p>

<p>For these reasons the overall recommendation is to use plf::colony for all
situations where (a) memory space is at a premium, (b) ordered insertion
doesn't matter, (c) maintaining valid pointers to container elements is
desirable and (d) insertions/erasures are occurring during operation. If
erasures and reinsertions are infrequent and memory is not at a premium then
you will be better off with a pointer_deque or indexed_vector approach.</p>

<p>plf::colony:<br>
<font style="color: green">Advantages: Fastest insertion and erase performance
except for deque_bool. Iteration performance very close to pointer_deque and
indexed_vector. Recycles or releases erased element memory locations. Best
overall performance where the ratio of insertions/erasures to iteration is
high. Insertion, erasure and iteration are all very fast.</font><br>
<font style="color: red">Disadvantages: Could be slower overall than
pointer_deque or indexed_vector approaches for situations where memory
expansion is not an issue, or where erasure and reinsertion are
infrequent.</font> </p>

<p>pointer_deque:<br>
<font style="color: green">Advantages: Best overall performance where the ratio
of insertions/erasures to iterations is low. A <i>remove_if</i> approach to
erasure can improve erasure times on large numbers of per-frame
erasures.</font><br>
<font style="color: red">Disadvantages: std::deque implementation structure is
compiler-dependent, so the above advantage will not apply generically
across-compilers. Will not release erased element locations to OS, or reuse
them. Slower erasure performance, so if erasure is very frequent, may be very
slow. Erasure time is less predictable and a detriment to latency-critical
programming.</font> </p>

<p>indexed_vector:<br>
<font style="color: green">Advantages: Almost as fast as pointer_deque
approach. Implementations do not vary so much from compiler to compiler,
meaning that this approach is more likely to yield benefits generically
compared to deque implementations.</font><br>
<font style="color: red">Disadvantages: Slower than pointer_deque approach, at
least under GCC. Approach requires any outside structures referring to it's
elements to use indexes instead of pointers, which complicates implementation,
as the structure must also know the container it is referring to. Will not
release erased element locations to OS, or reuse them. Slower erasure
performance than pointer_deque under GCC, so if erasure is very frequent, may
be extremely slow. A <i>remove_if</i> erasure pattern significantly improves
performance for large numbers of erasures but performs worse with low numbers,
and overall is worse than plf::colony performance. This erasure cost may be
reduced by using smaller datatypes for indexes, for example an unsigned short
when it is known that the number of elements will not exceed 65535 - hence
reducing the amount of data needing to be reallocated upon erasures. Erasure
time is less predictable and a detriment to latency-critical
programming.</font> </p>

<h2><a id="faq"></a>Frequently Asked Questions</h2>
<ol>
  <li><h4>TLDR, what is a colony?</h4>
    <p>A combination of a linked-list of increasingly-large memory blocks with
    metadata, combined with a jump-counting skipfield, combined with an
    erased-element memory-location stack for later reinsertions, resulting in a
    std::-styled C++ template data container with positive performance
    characteristics while maintaining pointer stability to container
    elements.</p>
  </li>
  <li><h4>Where is it worth using in place of other std:: containers?</h4>
    <p>It is most worthwhile, for performance reasons, in situations where the
    order of container elements is not important, and:</p>
    <ol type="a">
      <li>Pointers and iterators which point to container elements must stay
        valid regardless of container insertions and erasures,<br>
        <br>
        <b>and/or</b><br>
      </li>
      <li>Insertions and erasures to the container will be occuring in realtime
        ie. in performance-critical code.</li>
    </ol>
    <p>Under these circumstances a colony will generally out-perform other
    std:: containers. In addition, because it never invalidates pointer
    references to container elements (except when the element being pointed to
    has been previously erased) it can make many programming tasks involving
    inter-relating structures in an object-oriented or modular environment much
    faster, and can be considered in those circumstances.</p>
  </li>
  <li><h4>What are some examples of situations where a colony might improve
    performance?</h4>
    <p>Some ideal situations to use a colony: quadtree, persistent octtree,
    general game entities or destructible-objects in a video game, anywhere
    where objects are being created and destroyed continuously. Also, anywhere
    where a vector of pointers to dynamically-allocated objects or a std::list
    would typically end up being used in order to preserve object
    references.</p>
  </li>
<li>
	<h4>What situations should you explicitly <i>not</i> use a colony for?</h4>

	<p>A colony should not be used as a stack, ie. erasing backwards from the back, and then filling, then erasing from the back, etc. In this case you should use a stack ie. plf::stack, std::vector or std::deque.
	The reason is that erasing backwards sequentially creates the greatest time complexity for skipfield updates, as does reinserting to the start of a sequentially-erased skipblock (which is what stack usage will entail).
	This effect is mitigated somewhat if an entire group is erased, in which case it is released to the OS and subsequent insertions will not be updating skipfields but simply pushing to back, but you'd still incur the skipfield update cost during erasure.</p>

	<p>In general you should avoid erasing sequentially during reverse iteration except where absolutely neccessary - the skipfield format is optimized for forward-iteration and forward sequential erasure.</p></li>


  <li><h4>What are the time complexities for general operations?</h4>
    <p>Insertion: If no erasures have occured, always O(1) amortised. If erasures have occured, O(random) with the range of the random number being between from O(1) and O(std::numeric_limits&lt;skipfield_type&gt;::max() - 2) (65533 by default unless an alternative skipfield type is specified upon template instantiation. Average time complexity varies based on erasure pattern, but with a random erasure pattern it's closer to O(1) amortized.</p>
    <p>Erase: If no consecutive erasures have occured, or only consecutive erasures prior to the element being erased have occured, O(1) amortised. Otherwise O(n), where n is the number of consecutive previously-erased elements after the element being erased, which will always be between from 1 and std::numeric_limits&lt;skipfield_type&gt;::max() - 2 (65533 by default unless an alternative skipfield type is specified upon template instantiation).<br>
	 Assuming ignorance of consecutive erasure placement by the programmer, average time complexity will vary based on erasure patterns and will appear to be O(random). But with a random erasure pattern it will be closer to O(1) amortized.</p>
    <p>std::find: O(n)</p>
    <p>Iterator operations:<br>
    ++ and -- : O(1) amortized<br>
    begin()/end(): O(1)<br>
    advance/next/prev: between O(1) and O(n), depending on current location,
    end location and state of colony. Average O(log N).</p>
  </li>

<li>
<h4>If the time complexities of the insert/erase functions are (kind of) O(random, ranged), why are they still quick?</h4>

<p>The skipfield for each group is contiguous and separate from the skipfields for other groups, and so fits into the cache easily (unless the skipfield type is changed); thus any changes to it can occur quickly - time complexity is, actually, no indicator of performance on a modern computer.</p>

<p>Colony now also uses memmove instead of iterative updates for all but one of the insert/erase operations, which again decreases performance cost. In modern implementations, memmove will typically be implemented in memory chunks, which may reduce further the time complexity. There is one situation in erase which does not use memmove, a rarer case where an element is erased and is surrounded on both sides by consecutive erased skipfield nodes. In this case it isn't actually possible to update the skipfield using memmove because the requisite numbers do not already exist in the skipfield and cannot be copied, so it is implemented as a vectorized update instead. But again due to a low amount of branching the actual time taken for the update is quite quick, regardless of the number of nodes that need to be updated.</p>
</li>

  <li><h4>Is it similar to a deque?</h4>
    <p>A deque is fairly dissimilar to a colony. A deque is a double-ended
    queue, which requires a bit of a different internal framework. It typically
    uses a vector of memory blocks, whereas a colony uses a linked list -
    essentially. A deque can't use a linked list of memory blocks because it will make some random_access iterator operations (eg. + operator) non-O(1). In addition, being a double-ended queue makes having a growth factor for memory blocks problematic because the rules for growth at each end of the queue become difficult to implement in a way which increase performance. And in fact, if you were to be remove memory blocks from within a deque, you could not utilize a growth factor because this would make the "+" iterator operator impossible to implement in O(1) time (as you would not be able to ascertain the size for each memory block without inspecting them all).</p>
	 <p>A deque and colony have no comparable performance characteristics except for
    insertion (for a decent deque implementation). Deque element erasure
    performance varies quite wildly depending on the compiler compared to
    std::vector, but is generally more similar to a vector's performance, and it does not free unused memory blocks to the OS once they
    are empty, unlike a colony. Lastly a deque invalidates references to
    subsequent container elements when erasing elements, which a colony does
    not.</p>
  </li>
  <li><h4>What are the thread-safe guarantees?</h4>
    <p>Unlike a std::vector, a colony can be read from and written to at the
    same time, however it cannot be iterated over and written to at the same
    time. If we look at a std::vector's threadsafe matrix, to see which basic
    operations can occur at the same time, it reads as follows (please note
    push_back() is the same as insertion in this regard):</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>std::vector</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, multiple reads and iterations over iterators can happen
    simultaneously, but the invalidation caused by insertion/push_back and
    erasure means those operations cannot occur at the same time as anything
    else.</p>
    <p>Colony on the other hand does not (mostly) invalidate pointers/iterators
    to elements during insertion and erasure (iterators == end() may be
    invalidated by subsequent insertions, and iterators/pointers to elements which are
    erased will become invalid), resulting in the following matrix:</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>plf::colony</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>Mostly</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Mostly</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>Mostly</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>Yes</td>
          <td>Mostly</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, reads may occur at the same time as insertions and
    erasures (provided that the element being erased is not the element being
    read), multiple reads and iterations may occur at the same time, but
    iterations may not occur at the same time as an erasure or insertion, as
    either of these may change the state of the skipfield which's being
    iterated over. Erasures will not invalidate iterators unless the iterator
    points to the erased element.</p>
    <p></p>
    <p>So, colony is inherently more threadsafe than a std::vector, but still
    has some areas which would require mutexes or atomics to navigate in a
    multithreaded environment.</p>
  </li>
  <li><h4>Any "gotcha"'s to watch out for?</h4>
    <p>Only a few:</p>
    <ol type="a">
      <li>"insert" placement can be at the back, front, or frankly anywhere in
        the container, depending on what's been erased previously and where it
        was. Insertion is essentially random unless no erasures have been made
        prior, or an equal number of erasures and insertions have been made
        prio.</li>
      <li>For architectural reasons, reserve can only reserve up to 65535
        elements. A fill-constructor can however create as many elements as
        possible.</li>
      <li>Once an element has been erased, any iterator or pointer pointing to
        that element is no longer valid. This is the same as vector and other
        std:: container rules, but not the same as an array. In the case of
        colony, the memory block the iterator pointed to may no longer exist,
        because, if it were the final remaining element in the memory block,
        the group containing the memory block will have been removed from the
        colony chain. Erasure of the specific element is the only way that
        iterators and pointers to a colony element can become invalidated.</li>
    </ol>
  </li>
  <li><h4>Any special-case uses?</h4>
    <p>In the special case where many, many elements are being continually
    erased/inserted in realtime, you might want to experiment with limiting the
    size of your internal memory groups in the constructor. The form of this is
    as follows:<br>
    <code>plf::vector&lt;object&gt; a_vector;<br>
    a_vector.change_group_sizes(500, 5000);</code><br>
    where the first number is the minimum size of the internal memory groups
    and the second is the maximum size. Note these can be the same size,
    resulting in an unchanging group size for the lifetime of the colony
    (unless <code>change_group_sizes</code> is called again or operator = is
    called).<br>
    One reason to do this is that it is slightly slower to pop an element
    location off the internal memory position recycling stack, than it is to
    insert a new element to the end of the colony (the default behaviour when
    there are no previously-erased elements). If there are any erased elements
    in the colony, the colony will recycle those memory locations, unless the
    entire group is empty, at which point it is freed to memory. So if a group
    size is large and many, many erasures occur but the group is not completely
    emptied, (a) the number of erased element locations in the recycling stack
    could get very large, resulting in a detriment to performance and (b)
    iteration performance will suffer. In that scenario you may want to run a
    benchmark limiting the minimum/maximum sizes of the groups, and tune it
    until you find optimal usage.</p>
    <p>Please note that the the fill, range and initializer-list constructors
    can also take group size parameters, making it possible to construct filled
    colonies using custom group sizes.</p>
  </li>
  <li><h4>What is colony's Abstract Data Type (ADT)?</h4>
    <p>While I am happy to be proven wrong I suspect colony is it's own
    abstract data type. Some have suggested it is most similar to a multiset or
    bag, which is probably true, but from my perspective a bag or multiset
    utilizes key values. Colony does not utilize key values, is searchable and
    sortable, but does not give the sort of functionality one would find in a
    bag (for example counting the number of times a specific value occurs).
    Others have suggested a deque, but actually there are three necessary
    aspects to colony which make it function as it does, and which define any
    implementation:</p>
    <ol>
      <li>A multiple-memory-block based allocation pattern which allows for the
        removal of memory blocks when they become empty of elements.</li>
      <li>A skipfield to indicate erasures instead of reallocating elements,
        the iteration of which should typically not necessitate the use of
        branching code.</li>
      <li>A mechanism for storing erased element locations to allow for reuse of erased
        element memory space upon subsequent insertion.</li>
    </ol>
    <p>In the case of my particular colony implementation I utilize a <a
    href="chained_group_allocation_pattern.htm">chained-group memory allocation
    pattern</a> because it appears to have better performance than the
    alternatives, arguably though this could be any multiple-memory-block
    allocation strategy. For the skipfield I utilize the <a
    href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> but if a more efficient skipfield implementation were
    available for a given platform, that could be used. While it is preferable
    that any skipfield used not utilize branching code - as a common boolean
    skipfield does - because of the performance detriment caused by this, it is
    possible there could be a computer architecture where the cost of branching
    is much lower. The main necessity is that the skipfield enables O(1) ++ and
    -- operations (otherwise iterators cannot be valid within the standard).
    For the stack I am using <a href="stack.htm">plf::stack</a> because
    according to benchmarks it is more efficient than the current standard
    library alternatives. But again, if a more efficient alternative were found
    it could be used instead.</p>
    <p>If we look at a deque, the only aspect out of those three that it
    shares, is (1) - utilizing a multiple-memory-block allocation pattern.
    Which isn't a strong association. If we look at a multiset, an unordered
    one could be implemented on top of a colony utilizing an additional hash
    table, and it would be more efficient than the current multiset
    implementations as shown in the GCC and MSVC benchmarks. But the necessity
    to add something to make it a multiset, ie. to take and store key values,
    means colony is probably not a multiset, and probably it's own abstract
    data type.</p>
  </li>
  <li><h4>Exception Guarantees?</h4>
    <p>For both colony and stack all operations which allocate memory have
    strong exception guarantees and will roll back if an exception occurs,
    except for operator = which has a basic exception guarantee (see below).
    For colony, iterators are bounded by asserts in debug mode, but unbounded
    in release mode, so it is possible for an incorrect use of an iterator
    (iterating past end(), for example) to trigger an out-of-bounds memory
    exception. These are the only two areas where exceptions can occur.</p>
    <p>Similarly with plf::stack, top() and pop() operations are assert-checked
    against stack emptiness in debug mode, but performing these functions on an
    empty stack in release mode results in undefined behaviour.</p>
    <p>The reason why operator = (for both colony and stack) only has a basic
    guarantee is they do not utilize the copy-swap idiom, as the copy-swap
    idiom significantly increases the chance of any exception occuring - this
    is because the most common way an exception tends to occur during a copy
    operation is due to a lack of memory space, and the copy-swap idiom doubles
    the memory requirement for a copy operation by constructing the copy before
    destructing the original data. This is doubly innappropriate in game
    development, which colony has been initially for, where memory constraints
    are often critical and the runtime lag from memory spikes can cause
    detrimental game performance. So in the case of colony and plf::stack, if a
    non-memory-allocation-based exception occurs during copy, the = operators
    will have already destructed their data, so the containers will be empty
    and cannot roll back - hence they have a basic guarantee, not a strong
    guarantee.</p>
  </li>
  <li><h4>Iterators not following rule of zero?</h4>
    <p>It was found under GCC that the high-modification scenario benchmarks
    suffered a 11% overall performance loss when iterator copy and move
    constructors/operators where not explicitly defined, possibly because GCC
    did not know to vectorise the operations without explicit code or because
    it implemented copy/swap idiom instead of copying directly. No performance
    gain was found under any tests when removing the copy and move
    constructors/operators.</p>
  </li>
<li><h4>Why must groups be removed when empty?</h4>

<p>Two reasons:<br>
1. If groups aren't removed then iterator ++ and -- operations become non-O(1) for time complexity, which makes them illegal according to the C++ standard. At the moment they are O(1) amortised, typically one update for both skipfield and element pointers, but two if a skipfield jump takes the iterator beyond the bounds of the current group and into the next group.<br>
If there are multiple empty groups in a row, ++ iteration essentially becomes O(random) because each group will require an op to check for emptiness and to jump to the next. Essentially you get the same scenario as you do with a boolean skipfield.<br>
2. Performance. Iterating over empty groups is slower than them not being present, and pushing to the back of the colony is faster than recycling memory locations. When a group is removed it's recyclable memory locations are also removed from the stack, hence subsequent insertions are also faster.</p></li>


<li><h4>Why use a stack instead of a free list for erased location storage?</h4>

<p>Two reasons:</p>
<ol>
<li>Colony elements are not guaranteed to be of sufficient size (32-bit on x86, 64-bit or greater on other architectures) to store a pointer. For smaller types and 64-bit pointers, a free list union would end up wasting more space than a 16-bit skipfield. While the use-cases in games indicate larger-than-scalar types, there has been some interest and indication of usefulness from the high-performance-computing and storage domains, and I cannot predict their data patterns or usage.</li>
<li>A free list will likely incur a significant number of cache misses and subsequent jitter when a colony memory block is freed to the OS. With a stack the erased locations are in contiguous memory space, so it is extremely fast and cache-friendly to process the stack and remove erased locations belonging to the memory block being freed. On the other hand with a free list, removing the erased locations involves iterating through the list - which will most likely skip randomly throughout the colony blocks, involving many cache misses - in order to locate the nodes belonging to the erased memory block and joining previous nodes to the next non-erased-block locations.</li>
</ol>
<p>In short, it's not an effective solution, though there are other scenarios where it is ideal.</p>
</li>

<li><h4>Why use two pointers for iterators rather than a single index and then dereferencing?</h4>
<p>It's faster. In attempting to two separate occasions to switch to an index-based iterator approach, utilizing two separate pointers was notably faster.</p>

<li>
<h4>Group sizes - what are they based on, how do they expand, etc</h4>

<p>Group sizes start from the minimum size defined either by the default (8 elements) or by the programmer (with a minimum of 4 elements). Subsequent group sizes then increase the <i>total capacity</i> of the colony by a factor of 2 (so, 1st group 8 elements, 2nd 8 elements, 3rd 16 elements, 4th 32 elements etcetera) until the maximum group size is reached. The default maximum group size is the maximum possible number that the skipfield bitdepth is capable of representing (std::numeric_limits&lt;skipfield_type&gt;::max()). By default the skipfield bitdepth is 16 so the maximum size of a group is 65535 elements. However the skipfield bitdepth is also a template parameter which can be set to any unsigned integer - unsigned char, unsigned int, Uint_64, etc. Unsigned short (guaranteed to be at least 16 bit, equivalent to C++11's int_least16_t type) was found to have the best performance in real-world testing due to the balance between memory contiguousness, memory waste and the restriction on skipfield update time complexity. It also fits the use-case of gaming better (as games tend to utilize 10-100000 elements per section).</p></li>

<li><h4>Why store a size member for each group when this can be obtained via <code>reinterpret_cast&lt;element_pointer_type&gt;(skipfield) - elements</code>?</h4>
<p>Because it's faster. While it can be obtained that way, having it precalculated gives a small but significant benefit. And it's only an additional 16 bits per group in most cases.</p>

</ol>
<br>
<br>


<h2><a id="version"></a>Version history</h2>
<ul>
  <li>2016-10-14: v3.75 - Added get_index_from_reverse_iterator(). Further optimization (and one minor correction) of the reduced_stack storage mechanism , leading to an 8% performance increase in general_use benchmarks for small structs. Additional minor optimization for C++03. Some code comment tidyup.</li>
  <li>2016-10-10: v3.73 - change_group_size functions no longer copy-construct into a new colony unless the stack is not empty, and either min_group_size is larger than the smallest group in the stack, or max_group_size is smaller than the largest group in the stack. Correction to change_group_sizes code (was clearing erased locations unnecessarily). Reinitialize function added, which supports the changing of group sizes for colonies of non-copy-constructible element types. Emplace changed to no longer require move semantics, which enables the use of non-move-constructible/non-copy-constructible types with colony (example: anything containing a std::mutex). Minor correction to colony test suite under C++03.</li>
  <li>2016-10-04: v3.72 - minor fix to erase.</li>
  <li>2016-10-03: v3.71 - Replaced all but one vectorizing skipfield update with memmove ops for greater performance. Colony is no longer dependent on plf::stack, now has it's own reduced-functionality internal structure. TLDR, slightly faster, slightly faster build time &amp; slightly less memory use. Colony and stack are no longer friends :( (aw). Updated documentation. Stack separated out of colony package and test suite and vice-versa. Added functions to convert element pointer to iterator, and to convert iterator to index and vice-versa. Removed pointer-based erase function (use get_iterator_from_pointer() instead and call erase() with the resultant iterator). Minor update to distance, advance, prev and next functions. Benchmark suite updated.</li>
  <li>2016-09-02: v3.61 - Slight performance improvement for general-use-cases
    for colony, small performance/usability improvements in benchmark suite.
    Tweak for MSVC2010 performance. Correction to stack emplace.</li>
  <li>2016-08-24: v3.6 - 8 percent speedup on iteration, vs v3.55, for colony
    with larger-than-scalar types. Performance increases and minor corrections
    in benchmark suite.</li>
  <li>2016-08-20: v3.55 - Updates to benchmark suite - now uses a faster
    xorshift-type rand generator and a fast_mod function, test differences
    between containers more obvious now. Memory approximation also now outside
    of main loops, test cases updated for general_use test. Entirely new
    test-case function. Minor performance enhancements to
    insert/erase/operator++ for colony + code tidy-up. Minor warning removal
    for test suite.</li>
  <li>2016-08-04: v3.51 - Correction to move-insert courtesy of Peet Nick.
    Removal of end-block edge-case scenario code, as it was found to be of such
    low statistical significance as to be useless. The fix increased memory use
    in the scenario of the edge case which might be it's own problem in most
    scenarios. To get around the edge case, if it occurs in a given context, an
    allocator approach would be most appropriate. Update to benchmark
  suite.</li>
  <li>2016-07-19: v3.5 - Colony now accepts a template parameter for the
    skipfield type. This enables the use of, for example, unsigned char as the
    skipfield type. The bitdepth of the unsigned integer also defines the
    default maximum size of colony groups. The benchmark suite has been updated
    with memory measurements for the general_use tests. General_use tests
    changed to percentage-based tests. Internal erased location stack now
    stores only element pointers, not full iterators. Storing just the pointer
    and having to reconstruct the iterator slows down reinsertion after an
    erase, but speeds up the erase itself and results in an overall performance
    improvement, as well as less memory consumption. Slight improvement for
    fill-insert. Sanity-checks for range-insert and initializer-list-insert
    implemented. Minor fix to C++03 support in benchmark suite.</li>
  <li>2016-07-4: v3.35 - Another compliance fix for benchmark suite in clang,
    courtesy of Arthur O'Dwyer.</li>
  <li>2016-07-3: v3.34 - Minor warning removal for test suite. Performance
    improvement for colony edge-case scenario where a single element is
    inserted and then erased repeatedly, and where the insertion point happens
    to be at the end of a memory block.</li>
  <li>2016-07-1: v3.33 - Empty destructors/constructors removed in iterators.
    Small compliancy fixes in both colony and benchmark suite. Thanks to Arthur
    O'Dwyer for this update.</li>
  <li>2016-06-25: v3.31 - Colony iterators no longer inherit from std::iterator
    and implement the required typedefs themselves. Code tidyup and minor
    changes. Default of 1 implemented for prev/next.</li>
  <li>2016-06-17: v3.30 - Correction to colony range constructor. Corrections
    to advance() asserts.</li>
  <li>2016-06-15: v3.29 - Support for stateful allocators added, to both colony
    and stack. More generic solution applied for preventing calls for
    fill-insert to be matched by range insert template.</li>
  <li>2016-06-14: v3.25 - Edge-case corrections to colony's clear(),
    range-insert and fill-insert functions. Minor performance improvement in
    erase edge-case. Removed older (colony-specific) range insert. Simplified
    constructors.</li>
  <li>2016-06-12: v3.22 - Range, fill and initializer-list based insert()'s and
    constructors now implemented in colony. Bugfix for Microsoft compilers.
    Warnings fix for clang. Reinitialize functions removed, replaced with
    change_group_sizes(), change_minimum_group_size() and
    change_maximum_group_size().</li>
  <li>2016-06-11: v3.19 - Minor bugfix to plf::stack.</li>
  <li>2016-06-9: v3.18 - Corrections to colony and stack C++11 typedefs. Some
    code tidyup. Minor code corrections. Simplified reserve() and
    shrink_to_fit() functions. Added trim_trailing_groups() function to stack.
    Minor performance improvements.</li>
  <li>2016-05-31: v3.16 - Corrections to colony and stack reserve(). Some code
    tidyup. Correction to test suite.</li>
  <li>2016-05-30: v3.15 - Colony and stack are now compliant with C++11 and
    C++14 <a
    href="http://en.cppreference.com/w/cpp/concept/Container">container</a>
    concepts. Vectorized some erasure and insertion operations resulting in
    better overall performance in some scenarios. Corrected edge case in
    reverse iteration operator ++. All iterators now bounded by asserts in
    debug mode. Correction to capacity functions.</li>
  <li>2016-05-26: v3.14 - Added swap (std::swap worked fine without it, mainly
    required for standards compliance, also is exception-safe) and max_size()
    functions to stack and colony.</li>
  <li>2016-05-24: v3.13 - erase(element_pointer) added to colony. This enables
    erasure via a colony element's pointer, rather than it's iterator. Slightly
    slower than iterator-based erasure as a lookup has to be done for the
    colony element's group. Update to test suite.</li>
  <li>2016-05-19: v3.11 - Fix for colony shrink_to_fit(), added special case to
    stack copy constructor for when source size &gt; max_group_size, colony and
    stack constructors now explicit. Update to test suite.</li>
  <li>2016-05-12: v3.10 - Both stack and colony no longer preallocate upon
    construction, only upon first insertion. Minor assert bugfix in colony.
    shrink_to_fit(), reserve() and capacity() functions added to both classes.
    Some code cleanup, corrections for C++03 and minor optimizations.</li>
  <li>2016-04-28: v3.05 - Removal of compiler-specific iteration code,
    resulting in 8% speedup for larger-than-scalar type iteration, 6% slowdown
    for scalar-type iteration, under GCC x64. MSVC unaffected by change.
    Addition of benchmark suite. Correction to plf_nanotimer under
  linux/bsd.</li>
  <li>2016-04-16: v3.04 - Corrections to reinitialize asserts. Added
    bound-checking asserts to advance/next/prev implementations.</li>
  <li>2016-03-26: v3.03 - Correction to operator = on colony. Replaced
    SDL2/SDL_Timer in benchmarks with plf_nanotimer, a cross-platform
    ~nanosecond-precision timer. Correction to end() and begin() overloads -
    internal begin/end iterator could previously be altered by user activity,
    in some cases. Correction to .next functions.</li>
  <li>2016-03-24: v3.02 - Small performance improvements. Fix for demo for
    regular SDL2 usage. Duplication of macros from plf_stack.h to plf_colony.h
    to fix issue when plf_stack.h is also used within project separately from
    plf_colony.h. </li>
  <li>2016-02-23: v3.01 - Colony now uses a <a
    href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> instead of a boolean field, which mitigates worst-case
    scenario performance by factors of ten. Iterators now bidirectional (but
    include &gt; &lt; &gt;= and &lt;= operators) instead of random-access, and
    compliant with C++-specification's time-complexity requirements (all
    operations O(1) amortised). +=, -=, - and + iterator operators relegated to
    advance, distance, next and prev functions under colony. There is greater
    compliance with allocators. Group size now limited to 65535 max for colony,
    to decrease memory wastage and improve skipfield performance. Various
    bugfixes and corrections. plf::stack storage limit no longer 32-bit uint
    max (relies on allocator to supply correct size_type). Added worst-case and
    best-case scenario tests to colony benchmark, and added std::stack
    comparison to plf::stack benchmark. Benchmarks yet to be updated in
  docs.</li>
  <li>2015-11-20: v2.34 - Correction to clear() and reinitialize()
  functions.</li>
  <li>2015-11-17: v2.33 - Minor bugfix for GCC versions &lt; 5.</li>
  <li>2015-11-2: v2.32 - Minor bugfix for non-trivial pointers and non-trivial
    stack contents.</li>
  <li>2015-10-31: v2.31 - Allocators which supply non-trivial pointers are now
    supported. Large macros removed. Some code cleanup and minor performance
    gain.</li>
  <li>2015-10-10: v2.26 - 'back()' in plf::stack changed to 'top()' to better
    reflect std:: library stack implementation function titles. Added standard
    container typedefs to colony and stack. Colony iterators now return
    element_allocator::pointer and element_allocator::reference instead of
    value_type * and value_type &amp;. Some minor code cleanup.</li>
  <li>2015-10-6: v2.24 - Bugfix for C++03 with x64 compilers. Minor
    corrections, performance improvements for C++03 compilers.</li>
  <li>2015-10-4: v2.21 - Improved gcc x64 iteration. std::find now working with
    reverse_iterator. reverse_iterator function corrections, performance
    improvements. Hintless allocators under C++11 now supported. Allocation now
    uses allocator_traits under C++11.</li>
  <li>2015-9-30: v2.13 - Fixed performance regression with small primitive
    types and MS VCC. Small bugfixes.</li>
  <li>2015-9-28: v2.12 - Added const_iterator, const_reverse_iterator, .cbegin,
    .cend, .crbegin, .crend. Some small bugfixes.</li>
  <li>2015-9-27: v2.00 - Larger performance improvements, particularly for
    small primitive type storage. Corrections to exception handling and EBCO.
    ".insert" replaces ".add" (realised there is precedence for
    non-position-based insert via unordered_map/unordered_set). Added postfix
    iterator increment and decrement. Zero-argument ".add()" and ".push()"
    function overloads removed (same thing achievable with
    "colony.insert(value_type());" and "stack.push(value_type());". Many
    bugfixes and general code cleanup.</li>
  <li>2015-9-15: v1.79 - Empty base class allocator optimisations and smaller
    optimisation.</li>
  <li>2015-9-1: v1.77 - Some small bugfixes.</li>
  <li>2015-8-30: v1.76 - Now exception-safe. Also fixed C++03 regression
  bug.</li>
  <li>2015-8-22: v1.75 - Iterators more compliant and now work with std::find
    and should work with other std:: algorithm functions. Native find functions
    removed. (iterator - iterator) and (iterator + iterator) support added
    (relatively useless to end-users, but required by some std::
  algorithms).</li>
  <li>2015-8-15: v1.73 - Correction to noexcept/nothrow use under some
    non-c++11 compilers. Some rvalue functions corrected.</li>
  <li>2015-8-3: v1.72 - Added noexcept to more functions.</li>
  <li>2015-7-20: v1.71 - Small correction to demo, changed a data member name
    in demo to remove conflict in MSVC 2015.</li>
  <li>2015-7-13: v1.70 - Added deque comparisons to performance tests - this
    was necessary because many people were making comparisons between colonies
    and deques, without understanding what a deque is and how it
  performs...</li>
  <li>2015-6-21: v1.69 - Code tidy-up.</li>
  <li>2015-6-16: v1.67 - Correction to VS2013/VS2010 support: move semantics
    and other C++11 facets enabled for MS compilers. Support for VS2012, VS2015
    and later added. Performance bottleneck in destructors in debug mode fixed.
    General cleanup. Some microoptimisations. Macros now better named to avoid
    conflicts.</li>
  <li>2015-5-30: v1.60 - Correction to add function, microoptimizations.</li>
  <li>2015-5-29: v1.53 - Performance improvement. Corrected move constructor
    and reverse_iterator function semantics.</li>
  <li>2015-5-28: v1.52 - Small correction.</li>
  <li>2015-5-26: v1.51 - Small performance improvement. In demo, including
    SDL.h caused some weird behaviour with timer when used, changed to
    SDL_timer.h. Benchmarks to be updated.</li>
  <li>2015-5-25: v1.50 - Microoptimizations, small improvements, fixed crash in
    demo where memory would overflow when compiled to x86 without LAA.</li>
  <li>2015-5-21: v1.43 - Minor performance improvements for release mode,
    larger improvements for debug mode.</li>
  <li>2015-5-16: v1.42 - Some demo corrections.</li>
  <li>2015-5-16: v1.41 - Fixed demo on pre-C++11 compilers. Minor fixes in code
    and corrections in tests. Performance improvements.</li>
  <li>2015-5-11: v1.40 - Improved iterator ++ speed and Add speed, added
    real-world OO performance tests to demo. Added max group-size tuning (max
    number of elements per group).</li>
  <li>2015-5-6: v1.34 - Improved iterator ++ speed under VC2010 and GCC
  x64.</li>
  <li>2015-5-5: v1.33 - Improved erase, and some small performance tweaks.</li>
  <li>2015-5-4: v1.32 - Minor fixes.</li>
  <li>2015-5-3: v1.31 - Resolved all current known edge-case crashes. Improved
    stack pop performance.</li>
  <li>2015-4-26: v1.20 - Found and resolved several edge-case bugs. Improved +,
    -, += and -= iterator operator performance tremendously.</li>
  <li>2015-4-18: v1.10 - Allocators fully supported now. Improved performance.
    Some bugfixes. Added std::iterator trait to iterator. Added large struct
    tests to demo. Improved realism of array tests.</li>
  <li>2015-4-13: v1.00 - Allocators now largely supported (some work to do).
    Erasure bug fixed. First proper release.</li>
  <li>2015-4-9: v0.983 - Updated demo to be more realistic for array usage and
    to run all tests sequentially.</li>
  <li>2015-4-6: v0.982 - Bugfixes, speedup, added find functions.</li>
  <li>2015-4-2: v0.98 - First release</li>
</ul>

<p><a id="contact"></a>Contact: <img alt="footer" src="footer.gif"><br>
plf:: library and this page Copyright (c) 2016, Matthew Bentley</p>
</body>
</html>
