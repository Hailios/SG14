<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="description" content="PLF C++ Library - plf::colony">
  <meta name="keywords"
  content="C++, C, vector, colony, plf::colony, speed, OO, containers, optimize, performance, pointer, iterator, invalidation, benchmarks, results, benchmark, vs, versus, std::list, std::map, std::multiset, std::vector, std::deque, vector, deque, packed array">
  <title>PLF C++ Library - plf::colony</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<a href="index.htm">Home</a> 

<h1>PLF C++ Library - plf::colony</h1>
<ul>
  <li><a href="#intro">Intro</a></li>
  <li><a href="#details">Implementation</a></li>
  <li><a href="#license">License</a></li>
  <li><a href="#download">Download</a></li>
  <li><a href="#functions">Function Descriptions and Syntax</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#faq">Frequently-asked Questions</a></li>
  <li><a href="#version">Version History</a></li>
  <li><a href="#contact">Contact</a></li>
</ul>

<h2><a id="intro"></a>Introduction</h2>

<p>A colony is the highest-performance C++ template-based data container for
high-modification scenarios with unordered data. Specifically it provides
better performance than other std:: library containers when:</p>
<ol type="a">
  <li>Insertion order is unimportant,</li>
  <li>Insertions and erasures to the container are occuring frequently in
    realtime ie. in performance-critical code, <i><b>and/or</b></i> </li>
  <li>Pointers which point to non-erased container elements must not be
    invalidated by insertion or erasure.</li>
</ol>

<p>While the benchmarks in the section below are a better area to get a feel
for the performance benefits, the general speed characteristics are:</p>
<ul>
  <li><i>Singular, unordered insertion</i>: better than any std:: library
    container except good implementations of deque.</li>
  <li><i>Erasure</i>: better than any std:: library container.</li>
  <li><i>Iteration</i>: better than any std:: library container where pointer
    validity to non-erased elements is important. Where pointer validity is
    unimportant, better than any std:: library container except deque and
    vector.</li>
</ul>

<p>As explored further in the benchmarks there are some <a
href="#comparative_tests">vector/deque modifications</a> which can outperform
colony during iteration while maintaining pointer validity, but at a cost to
usability and memory usage. Colony's other advantages include the freeing and
recycling of unused memory on-the-fly, the guaranteed stability of
pointers/references/iterators to non-erased elements (which makes programming
with containers of inter-related data structures faster and much easier), and
broad cross-compiler support.</p>

<p>It can be reasonably compared to a "bag" or "bucket-array" styled structure,
where each element location can be emptied and skipped over. Unlike a bucket
array it does not use keys, iterates faster due to the use of a <a
href="skipfield_comparison.htm">jump-counting skipfield</a> instead of a
boolean field, and frees or recycles unused memory from erased element
locations on the fly. As it was initially developed predominantly for game
development, colony favours larger-than-scalar-type (structs/classes of
greater-than 128 bits total) performance over scalar-type (float, int, etc)
performance.</p>

<h2><a id="motivation"></a>Motivation</h2>

<p><i>Note: initial motivation for the project came from video game engine
development. Since this point it has become a more generalized container.
Nevertheless, the initial motivation is presented below.</i><br>
When working on video game engines we are predominantly dealing with
collections of data where:</p>
<ol type="a">
  <li>Elements within data collections refer to elements within other data
    collections (through a variety of methods - indices, pointers, etc). An
    example is a game entity referring to both a texture object and collision
    blocks, as well as sound data. These references must stay valid throughout
    the course of the game/level. For this reason, any container (or use of a
    container) which causes pointer or index invalidation can create
    difficulties or necessitate workarounds.</li>
  <li>Order is unimportant for the most part. The majority of data collections
    are simply iterated over, transformed, referred to and utilized with no
    regard to order.</li>
  <li>Erasing or otherwise removing or deactivating objects occurs frequently
    in-game and in realtime (though often erasures will be implemented to occur
    at the end of a frame due to multithreading concerns). An example could be
    destroying a wall, or a game enemy. For this reason methods of erasure
    which create strong performance penalties are avoided.</li>
  <li>Creating new objects and adding them into the gameworld on-the-fly is
    also common - for example, a tree which drops leaves every so often, or a
    quadtree.</li>
  <li>We don't always know in advance how many elements there will be in a
    container at the beginning of development, or even at the beginning of a
    level during playback - an example of this being a MMORPG (massively
    multiplayer online role-playing game). In a MMORPG the number of game
    entities fluctuates based on how many players are playing, though there may
    be maximum capacity limits. Genericized game engines in particular have to
    adapt to considerably different user requirements and scopes. For this
    reason extensible containers which can expand and contract in realtime are
    usually necessary.</li>
  <li>Depending on the complexity and scope of any given game, we can be
    dealing with anywhere between 10 and 100000 objects in a given area. We are
    not typically dealing with the types of capacities necessitated by
    large-scale mathematical or statistical applications.</li>
  <li>For performance reasons, memory storage which is more-or-less contiguous
    is preferred. Lists, vectors of pointers to dynamically-allocated objects,
    and maps as implemented in the standard library are unusable.</li>
  <li>Memory wastage is avoided, and in particular, any container which
    allocates upon initialisation tends to be avoided as this can incur
    purposeless memory and performance costs.</li>
</ol>
<br>


<p>To meet these requirements, game developers tend to either (a) develop their
own custom containers for given scenario or (b) develop workarounds for the
failings of std::vector. These workarounds are many and varied, but the most
common are probably:</p>
<ol>
  <li>Using a boolean flag (or similar) to indicate the inactivity of an object
    (as opposed to actually erasing from the vector). When erasing, one simply
    adjusts the boolean flag, and when iterating, items with the adjusted
    boolean flag are skipped. External elements refer to elements within the
    container via indexes rather than pointers (which can be invalidated upon
    insertion). 
    <p>Advantages: Fast erasure.</p>
    <p>Disadvantages: Slow to iterate due to branching.</p>
  </li>
  <li>Utilizing a vector of data with a secondary vector of indexes. When
    erasing, the erasure occurs in the vector of indexes, not the vector of
    data, and when iterating, one iterates over the vector of indexes, then
    accessing the data from the vector of data via the index. 
    <p>Advantages: Faster iteration.</p>
    <p>Disadvantages: Erasure still incurs some reallocation cost, can increase
    jitter.</p>
  </li>
  <li>Combining a swap-and-pop mechanism with some form of dereferenced lookup
    system to enable contiguous element iteration (sometimes known as a <a
    href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">'packed
    array'</a>, various other names). In this case when erasing we swap the
    back element from the vector of elements with the element being erased,
    then pop the (swapped) back element. When iterating over the data we simply
    iterate through the vector of elements. However to maintain valid external
    links to elements (which may be moved at any time) we must also maintain a
    stable vector of indexes (or similar) and update the index numbers
    corresponding with the element being erased and the element being moved. In
    this case external objects referring to elements within the container must
    store a pointer to the index for the element in question. There are many
    varied alternatives to this method. The method is more useful when the
    container's data is mostly being iterated over with fewer references to the
    individual elements from outside objects. 
    <p>Advantages: Iteration is at standard vector speed.</p>
    <p>Disadvantages: Erase could be slow if objects are large and swap cost is
    therefore large. Insertion cost is larger than other techniques. All
    references to elements incur additional costs due to a two-fold reference
    mechanism.</p>
  </li>
</ol>
<br>


<p>All three techniques have the disadvantage of slow singular insertions, and
the first two will also continually expand memory usage when erasing and
inserting over periods of time. The third deals better with this scenario as it
swaps from the back rather than leaving gaps in the elements vector, however
will suffer in performance if elements within the container are heavily
referred to by external objects/elements.</p>

<p>Colony is an attempt to bring a more generic solution to this domain. It has
the advantage of good iteration speed while maintaining a similar erasure speed
to the boolean technique described above, and without causing pointer
invalidation upon either erasure or insertion. It's insertion speed is also
much faster than a vector's. Memory from erased elements is either reused by
subsequent insertions or released to the OS on-the-fly. It achieves these ends
by via a number of new approaches: a <a
href="skipfield_comparison.htm">jump-counting skipfield</a> (instead of a
boolean field), a <a href="chained_group_allocation_pattern.htm">linked
chain</a> of increasingly-large memory blocks (instead of a singular memory
block or vector of blocks), and a custom internal reduced stack (based on <a
href="stack.htm">plf::stack</a>) to enable erased memory location re-use.</p>

<p>More data on the performance characteristics of the colony versus other
containers and workarounds can be found in the <a href="#benchmarks">benchmarks
section</a>, read below to gain an understanding of the mechanics.</p>

<h2><a id="details"></a>Implementation</h2>

<p>plf::colony uses a <a
href="chained_group_allocation_pattern.htm">chained-group memory allocation
pattern</a> with a growth factor of 2, (doubly-linked chains of element
"groups" containing memory blocks with additional structure metadata, including
in this case per-memory-block jump-counting skipfields). A growth factor of 2
tends gives the best performance in a majority of scenarios (hence why it is
used for the majority of vector implementations). Colony's minimum and maximum
memory block sizes can also be adjusted to suit individual use-cases. Using a
multiple-memory-block approach removes the necessity for data reallocation upon
insertion, and because data is not reallocated, all
references/pointers/iterators to container elements stay valid
post-insertion.</p>

<p>Due to a std::vector being the most widely-used and commonly-understood of
the std:: library containers, we here contrast the storage mechanisms of a
colony with that of a vector:</p>
<img src="vector_addition.gif"
alt="Visual demonstration of inserting to a full vector" height="540"
width="960"> <img src="colony_addition.gif"
alt="Visual demonstration of inserting to a full colony" height="540"
width="960"> 

<p>The lack of reallocation is also why insertion into a colony is faster than
insertion into a std::vector. Now we look at erasure. When an element is erased
in a std::vector, the following happens:</p>

<p><img src="vector_erasure.gif"
alt="Visual demonstration of randomly erasing from a vector" height="540"
width="960"> </p>

<p>When an element is erased in a colony, this happens:</p>
<img src="colony_erasure.gif"
alt="Visual demonstration of randomly erasing from a colony" height="540"
width="960"> 

<p>This is why a colony has a performance advantage over std::vector when
erasing. </p>

<p>Upon subsequent insertions to a colony post-erasure, colony will check to
see if it's erased-location stack is empty. If it is empty, it inserts to the
end of the colony, creating a new group if the last group is full. If it is not
empty, it pops an erased element location off the stack and reuses that memory
address for the newly-inserted element. If you erase all elements in any given
group in a colony, the group is removed from the colony's chain and released to
the OS - at that point any erased element locations present in the
erased-location stack are also removed.</p>

<h2><a id="license" name="license"></a>License</h2>

<p>plf::colony is under a permissive <a
href="http://en.wikipedia.org/wiki/Zlib_License">zlib license</a>. This means:
Software is used on 'as-is' basis. It can be modified and used in commercial
software. Authors are not liable for any damages arising from its use. The
distribution of a modified version of the software is subject to the following
restrictions:</p>
<ul>
  <li>The authorship of the original software must not be misrepresented,</li>
  <li>Altered source versions must not be misrepresented as being the original
    software, and</li>
  <li>The license notice must not be removed from source distributions.</li>
</ul>

<h2><a id="download"></a>Download</h2>

<p>Download <a href="plf_colony_28-04-2017.zip">here</a> (26kb zip file) or
view the <a
href="https://github.com/mattreecebentley/plf_colony">repository</a><br>
<br>
The colony library is a simple .h header file, to be included with a #include
command.<br>
<br>
In addition if you are interested in benchmarking you can also download the <a
href="plf_benchmark_suite_8-2-2017.zip">plf benchmark suite</a> (36kb zip
file), which includes plf::nanotimer.</p>

<h2><a id="functions"></a>Function Descriptions and syntax</h2>

<p>Colony meets the requirements of the C++ <a
href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a
href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>,
and <a
href="http://en.cppreference.com/w/cpp/concept/ReversibleContainer">ReversibleContainer</a>
concepts.</p>

<p>For the most part the syntax and semantics of colony functions are very
similar to all std:: c++ libraries. Formal description is as follows:</p>
<code>template &lt;class T, class Allocator = std::allocator&lt;T&gt;, typename
Skipfield_Type = unsigned short&gt; class colony</code> 

<p><code><b>T</b></code> - the element type. In general T must meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>, <a
href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>
and <a
href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a>.<br>
However, if emplace is utilized to insert elements into the colony, and no
functions which involve copying or moving are utilized, T is only required to
meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>.<br>
If move-insert is utilized instead of emplace, T must also meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a>
 .<br>
<br>
<code><b>Allocator</b></code> - an allocator that is used to acquire memory to
store the elements. The type must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Allocator">Allocator</a>. The
behavior is undefined if <code>Allocator::value_type</code> is not the same as
T.<br>
<br>
<code><b>T_skipfield_type</b></code> - an unsigned integer type. This type is
used to form the skipfield which skips over erased T elements. The maximum size
of element memory blocks is constrained by this type's bit-depth (due to the
nature of a jump-counting skipfield). As an example, <code>unsigned
short</code> on most platforms is 16-bit which thereby constrains the size of
individual memory blocks to a maximum of 65535 elements. <code>unsigned
short</code> has been found to be the optimal type for performance based on
benchmarking. However this template parameter is important for a variety of
scenarios relating to performance or memory usage. In the case of small
collections (eg. &lt; 512 elements) in a memory-constrained environment, it is
useful to reduce the memory usage of the skipfield by reducing the skipfield
bit depth to a Uint8 type. In addition the reduced skipfield size will reduce
cache saturation in this case without impacting iteration speed due to the low
element total. In the case of very large collections (millions) and where
memory usage is not a concern, changing the skipfield bitdepth to a larger type
leads to slightly increased iteration performance (offset by decreased erasure
and insertion performance) due to the larger memory block sizes made possible
by the larger bit depth. Since these scenarios are on a per-case basis, it is
best to leave the control in the user's hands.</p>

<h4>Basic example of usage</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;

  <span style="color: #888888">// Insert 100 ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    i_colony.insert(i);
  }

  <span style="color: #888888">// Erase half of them:</span>
  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Total the remaining ints:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>it;
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Example demonstrating pointer stability</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;</span> p_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;::</span>iterator p_it;

  <span style="color: #888888">// Insert 100 ints to i_colony and pointers to those ints to p_colony:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    it <span style="color: #333333">=</span> i_colony.insert(i);
    p_colony.insert(<span style="color: #333333">&amp;</span>(<span style="color: #333333">*</span>it));
  }

  <span style="color: #888888">// Erase half of the ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Erase half of the int pointers:</span>
  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    p_it <span style="color: #333333">=</span> p_colony.erase(p_it);
  }

  <span style="color: #888888">// Total the remaining ints via the pointer colony (pointers will still be valid even after insertions and erasures):</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>(<span style="color: #333333">*</span>p_it);
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  
  <span style="color: #008800; font-weight: bold">if</span> (total <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2500</span>)
  {
    std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Pointers still valid!"</span> <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  }
  
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Iterator Invalidation</h4>

<table border="1">
  <tbody>
    <tr>
      <td>All read-only operations, swap, std::swap</td>
      <td>Never</td>
    </tr>
    <tr>
      <td>clear, reinitialize, operator = </td>
      <td>Always</td>
    </tr>
    <tr>
      <td>reserve, shrink_to_fit</td>
      <td>Only if capacity is changed</td>
    </tr>
    <tr>
      <td>change_group_sizes, change_minimum_group_size,
        change_maximum_group_size</td>
      <td>Only if supplied minimum group size is larger than smallest group in
        colony, or supplied maximum group size is smaller than largest group in
        colony.</td>
    </tr>
    <tr>
      <td>erase</td>
      <td>Only for the erased element. If an iterator is == end() it may be
        invalidated if the last element in the colony is erased, in some cases.
        If a reverse_iterator is == rend() it may be invalidated if the first
        element in the colony is erased, in some cases.</td>
    </tr>
    <tr>
      <td>insert, emplace</td>
      <td>If an iterator is == end() it may be invalidated by a subsequent
        insert/emplace, in some cases.</td>
    </tr>
  </tbody>
</table>

<h4>Member types</h4>

<table border="1">
  <tbody>
    <tr>
      <td><b>Member type</b></td>
      <td><b>Definition</b></td>
    </tr>
    <tr>
      <td><code>value_type</code></td>
      <td><code>T</code></td>
    </tr>
    <tr>
      <td><code>allocator_type</code></td>
      <td><code>Allocator</code></td>
    </tr>
    <tr>
      <td><code>skipfield_type</code> </td>
      <td><code>T_skipfield_type</code> </td>
    </tr>
    <tr>
      <td><code>size_type</code></td>
      <td><code>Allocator::size_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::size_type
      (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>difference_type</code></td>
      <td><code>Allocator::difference_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::difference_type
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>reference</code></td>
      <td><code>Allocator::reference (pre-c++11)<br>
        value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_reference</code></td>
      <td><code>Allocator::const_reference (pre-c++11)<br>
        const value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>pointer</code></td>
      <td><code>Allocator::pointer (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::pointer (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_pointer</code></td>
      <td><code>Allocator::const_pointer (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::const_pointer
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>reverse_iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_reverse_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
  </tbody>
</table>

<h3>Constructors</h3>

<table border="1">
  <tbody>
    <tr>
      <td><code>colony()</code></td>
      <td><code>explicit colony(const allocator_type &amp;alloc)</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>explicit colony(size_type n, Skipfield_type min_group_size = 8,
        Skipfield_type max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        explicit colony(size_type n, const value_type &amp;element,
        Skipfield_type min_group_size = 8, Skipfield_type max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type()) </code> </td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template&lt;typename InputIterator&gt; colony(const
        InputIterator &amp;first, const InputIterator &amp;last, Skipfield_type
        min_group_size = 8, Skipfield_type max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        </code> </td>
    </tr>
    <tr>
      <td>copy</td>
      <td><code>colony(const colony &amp;source)</code> </td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>colony(colony &amp;&amp;source) noexcept</code> <font
        size="2">(C++11 and upwards)</font></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>colony(const std::initializer_list&lt;value_type&gt;
        &amp;element_list, Skipfield_type min_group_size = 8, Skipfield_type
        max_group_size = std::numeric_limits&lt;Skipfield_type&gt;::max(),
        const allocator_type &amp;alloc = allocator_type()) </code> </td>
    </tr>
  </tbody>
</table>

<h5>Some constructor usage examples</h5>
<ul>
  <li><code>colony&lt;T&gt; a_colony</code> 
    <p>Default constructor - default minimum group size is 8, default maximum
    group size is std::numeric_limits&lt;Skipfield_type&gt;::max() (typically
    65535). You cannot set the group sizes from the constructor in this
    scenario, but you can call the change_group_sizes() member function after
    construction has occurred. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony;</code> </p>
  </li>
  <li><code>colony&lt;T, the_allocator&lt;T&gt; &gt; a_colony(const
    allocator_type &amp;alloc = allocator_type())</code> 
    <p>Default constructor, but using a custom memory allocator eg. something
    other than std::allocator. <br>
    Example: <code style="color: brown">plf::colony&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_colony;</code> <br>
    Example2: <br>
    <code style="color: brown">// Using an instance of an allocator as well as
    it's type<br>
    tbb::allocator&lt;int&gt; alloc_instance;<br>
    plf::colony&lt;int, tbb::allocator&lt;int&gt; &gt;
    int_colony(alloc_instance);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; colony(size_type n, Skipfield_type min_group_size =
    8, Skipfield_type max_group_size =
    std::numeric_limits&lt;Skipfield_type&gt;::max())</code> 
    <p>Fill constructor with value_type unspecified, so the value_type's
    default constructor is used. <code>n</code> specifies the number of
    elements to create upon construction. If <code>n</code> is larger than
    <code>min_group_size</code>, the size of the groups created will either be
    <code>n</code> and <code>max_group_size</code>, depending on which is
    smaller. <code>min_group_size</code> (ie. the smallest possible number of
    elements which can be stored in a colony group) can be defined, as can the
    <code>max_group_size</code>. Setting the group sizes can be a performance
    advantage if you know in advance roughly how many objects are likely to be
    stored in your colony long-term - or at least the rough scale of storage.
    If that case, using this can stop many small initial groups being
    allocated. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony(62);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; colony(const
    std::initializer_list&lt;value_type&gt; &amp;element_list,<br>
    Skipfield_type min_group_size = 8, Skipfield_type max_group_size =
    std::numeric_limits&lt;Skipfield_type&gt;::max())</code> 
    <p>Using an initialiser list to insert into the colony upon construction.
    <br>
    Example: <code style="color: brown">std::initializer_list&lt;int&gt;
    &amp;el = {3, 5, 2, 1000};<br>
    plf::colony&lt;int&gt; int_colony(el, 64, 512);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const colony &amp;source)</code> 
    <p>Copy all contents from source colony, removes any empty (erased) element
    locations in the process. Size of groups created is either the total size
    of the source colony, or the maximum group size of the source colony,
    whichever is the smaller. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(int_colony_1);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(colony &amp;&amp;source)</code> 
    <p>Move all contents from source colony, does not remove any erased element
    locations or alter any of the source group sizes. Source colony is now void
    of contents and can be safely destructed. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt; int_colony_1(50,
    5, 512, 512); // Create colony with min and max group sizes set at 512
    elements. Fill with 50 instances of int = 5.<br>
    plf::colony&lt;int&gt; int_colony_2(std::move(int_colony_1)); // Move all
    data to int_colony_2. All of the above characteristics are now applied to
    int_colony2.</code> </p>
  </li>
</ul>

<h3>Iterators</h3>

<p>All iterators are bidirectional but also provide &gt;, &lt;, &gt;= and &lt;=
for convenience (for example, in <code>for</code> loops). Functions for
iterator, reverse_iterator, const_iterator and const_reverse_iterator
follow:</p>

<p><code>operator * <br>
operator -&gt; <br>
operator ++<br>
operator --<br>
operator = <br>
operator == <br>
operator != <br>
operator &lt;  <br>
operator &gt;  <br>
operator &lt;=  <br>
operator &gt;=  <br>
base() (reverse_iterator and const_reverse_iterator only)</code> </p>

<p>All operators have O(1) amortised time-complexity. Originally there were +=,
-=, + and - operators, however the time complexity of these varied from O(n) to
O(1) depending on the underlying state of the colony, averaging in at O(log n).
As such they were not includable in the iterator functions (as per C++
standards). These have been transplanted to colony's advance(), next(), prev()
and distance() member functions. Greater-than/lesser-than operator usage
indicates whether an iterator is higher/lower in position compared to another
iterator in the same colony (ie. closer to the end/beginning of the colony).
const_iterator is provided for both C++03 and C++11/14/etc compilers.</p>

<h3>Member functions</h3>

<h4>Insert</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator insert (const value_type &amp;val)</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>iterator insert (const size_type n, const value_type
        &amp;val)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template &lt;class InputIterator&gt; iterator insert (const
        InputIterator first, const InputIterator last)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>iterator insert (value_type&amp;&amp; val) <font
        size="2">(C++11 and upwards)</font></code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>iterator insert (const std::initializer_list&lt;value_type&gt;
        il)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator insert(const value_type &amp;element)</code> 
    <p>Inserts the element supplied to the colony, using the object's
    copy-constructor. Will insert the element into a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(23);</code> </li>
  <li><code>iterator insert (const size_type n, const value_type
    &amp;val)</code> 
    <p>Inserts <code>n</code> copies of <code>val</code> into the colony. Will
    insert the element into a previously erased element slot if one exists,
    otherwise will insert to back of colony. Returns iterator to location of
    first inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(10, 3);</code> </li>
  <li><code>template &lt;class InputIterator&gt; iterator insert (const
    InputIterator &amp;first, const InputIterator &amp;last)</code> 
    <p>Inserts a series of <code>value_type</code> elements from an external
    source into a colony holding the same <code>value_type</code> (eg. int,
    float, a particular class, etcetera). Stops inserting once it reaches
    <code>last</code>. Example:</p>
    <code style="color: brown">// Insert all contents of colony2 into
    colony1:<br>
    colony1.insert(colony2.begin(), colony2.end());</code> </li>
  <li><code>iterator insert(value_type &amp;&amp;element) <b>C++11 and
    upwards</b></code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::string string1 = "Some text";<br>
    <br>
    plf::colony&lt;std::string&gt; data_colony;<br>
    data_colony.insert(std::move(string1));</code></p>
  </li>
  <li><code>iterator insert (const std::initializer_list&lt;value_type&gt;
    &amp;il)</code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::initializer_list&lt;int&gt; some_ints =
    {4, 3, 2, 5};<br>
    <br>
    plf::colony&lt;int&gt; i_colony;<br>
    i_colony.insert(some_ints);</code></p>
  </li>
</ul>

<h4>Erase</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator erase(const_iterator it)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>void erase(const_iterator first, const_iterator
      last)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator erase(const_iterator it)</code> 
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Returns an iterator pointing to the next non-erased element in the
    colony (or to end() if no more elements are available). This must return an
    iterator because if a colony group becomes entirely empty, it will be
    removed from the colony, invalidating the existing iterator. Attempting to
    erase a previously-erased element results in undefined behaviour (this is
    checked for via an assert in debug mode). Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.insert(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const_iterator first, const_iterator last)</code> 
    <p>Erases all contents of a given colony from <code>first</code> to the
    element before the <code>last</code> iterator. This function is optimized
    for multiple consecutive erasures and will always be faster than sequential
    single-element erase calls in that scenario. Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin();<br>
    colony1.advance(iterator1, 10);<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin();<br>
    colony1.advance(iterator2, 20);<br>
    colony1.erase(iterator1, iterator2);</code> </li>
</ul>

<h4>Other functions</h4>
<ul>
  <li><code>iterator emplace(Arguments &amp;&amp;...parameters) <b>C++11 and
    upwards</b></code> 
    <p>Constructs new element directly within colony. Will insert the element
    in a previously erased element slot if one exists, otherwise will insert to
    back of colony. Returns iterator to location of inserted element.
    "...parameters" are whatever parameters are required by the object's
    constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
    int number;<br>
    public:<br>
    simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns a boolean indicating whether the colony is currently empty of
    elements.<br>
    Example: <code style="color: brown">if (object_colony.empty())
    return;</code></p>
  </li>
  <li><code>size_type size()</code> 
    <p>Returns total number of elements currently stored in container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type max_size()</code> 
    <p>Returns the maximum number of elements that the allocator can store in
    the container. This is an approximation as it does attempt to measure the
    memory overhead of the container's internal memory structures. It is not
    possible to measure the latter because a copy operation may change the
    number of groups utilized for the same amount of elements, if the maximum
    or minimum group sizes are different in the source container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.max_size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type capacity()</code> 
    <p>Returns total number of elements currently able to be stored in
    container without expansion.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.capacity()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>void shrink_to_fit()</code> 
    <p>Reduces container capacity to the amount necessary to store all
    currently stored elements. If the total number of elements is larger than
    the maximum group size, the resultant capacity will be equal to
    <code>((total_elements / max_group_size) + 1) * max_group_size</code>
    (rounding down at division). Invalidates all pointers, iterators and
    references to elements within the container.<br>
    Example: <code style="color: brown">i_colony.shrink_to_fit();</code></p>
  </li>
  <li><code>void reserve(unsigned short reserve_amount)</code> 
    <p>Preallocates memory space sufficient to store the number of elements
    indicated by <code>reserve_amount</code>. The maximum size for this number
    is limited to the maximum group size of the colony and will be truncated if
    necessary. The default maximum group size is 65535 on the majority of
    platforms.<br>
    Example: <code style="color: brown">i_colony.reserve(15);</code></p>
  </li>
  <li><code>void clear()</code> 
    <p>Empties the colony and removes all elements and groups.<br>
    Example: <code style="color: brown">object_colony.clear();</code></p>
  </li>
  <li><code>void change_group_sizes(const unsigned short min_group_size, const
    unsigned short max_group_size)</code> 
    <p>Changes the minimum and maximum internal group sizes, in terms of number
    of elements stored per group. If the colony is not empty and either
    min_group_size is larger than the smallest group in the colony, or
    max_group_size is smaller than the largest group in the colony, the colony
    will be internally copy-constructed into a new colony which uses the new
    group sizes, invalidating all pointers/iterators/references.<br>
    Example: <code style="color: brown">object_colony.change_group_sizes(1000,
    10000);</code></p>
  </li>
  <li><code>void change_minimum_group_size(const unsigned short
    min_group_size)</code> 
    <p>Changes the minimum internal group size only, in terms of minimum number
    of elements stored per group. If the colony is not empty and min_group_size
    is larger than the smallest group in the colony, the colony will be
    internally copy-constructed into a new colony which uses the new minimum
    group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_minimum_group_size(100);</code></p>
  </li>
  <li><code>void change_maximum_group_size(const unsigned short
    min_group_size)</code> 
    <p>Changes the maximum internal group size only, in terms of maximum number
    of elements stored per group. If the colony is not empty and either
    max_group_size is smaller than the largest group in the colony, the colony
    will be internally copy-constructed into a new colony which uses the new
    maximum group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_maximum_group_size(1000);</code></p>
  </li>
  <li><code>void reinitialize(const unsigned short min_group_size, const
    unsigned short max_group_size)</code> 
    <p>Semantics of function are the same as "clear();
    change_group_sizes(min_group_size, max_group_size);", but without the
    copy-construction code of the change_group_sizes() function - this means it
    can be used with element types which are non-copy-constructible, unlike
    change_group_sizes().<br>
    Example: <code style="color: brown">object_colony.reinitialize(1000,
    10000);</code></p>
  </li>
  <li><code>void swap(colony &amp;source)</code> 
    <p>Swaps the colony's contents with that of <code>source</code>.<br>
    Example: <code
    style="color: brown">object_colony.swap(other_colony);</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;source)</code> 
    <p>Copy the elements from another colony to this colony, clearing this
    colony of existing elements first.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++03<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;&amp;source) <b>C++11
    only</b></code> 
    <p>Move the elements from another colony to this colony, clearing this
    colony of existing elements first. Source colony becomes invalid but can be
    safely destructed without undefined behaviour.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code></p>
  </li>
  <li><code>bool operator == (const colony &amp;source)</code> 
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are equal.<br>
    Example: <code style="color: brown">if (object_colony == object_colony2)
    return;</code></p>
  </li>
  <li><code>bool operator != (const colony &amp;source)</code> 
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are not equal.<br>
    Example: <code style="color: brown">if (object_colony != object_colony2)
    return;</code></p>
  </li>
  <li><code>iterator begin(), iterator end(), const_iterator cbegin(),
    const_iterator cend()</code> 
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony (as per standard STL
    guidelines).</p>
  </li>
  <li><code>reverse_iterator rbegin(), reverse_iterator rend(),
    const_reverse_iterator crbegin(), const_reverse_iterator crend()</code> 
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony (as
    per standard STL guidelines).</p>
  </li>
  <li><code>iterator get_iterator_from_pointer(const element_pointer_type
    the_pointer) <b>(slow)</b></code> 
    <p>Getting a pointer from an iterator is simple - simply dereference it
    then grab the address ie. <code>"&amp;(*the_iterator);"</code>. Getting an
    iterator from a pointer is typically not so simple. This function enables
    the user to do exactly that. This is expected to be useful in the use-case
    where external containers are storing pointers to colony elements instead
    of iterators (as iterators for colonies have 3 times the size of an element
    pointer) and the program wants to erase the element being pointed to or
    possibly change the element being pointed to. Converting a pointer to an
    iterator using this method and then erasing, is about 20% slower on average
    than erasing when you already have the iterator. This is less dramatic than
    it sounds, as it is still faster than all std:: container erasure times
    which it is roughly equal to. However this is generally a slower,
    lookup-based operation. If the lookup doesn't find a non-erased element
    based on that pointer, it returns <code>end()</code>. Otherwise it returns
    an iterator pointing to the element in question. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    a_struct *struct_pointer = &amp;(*an_iterator);<br>
    iterator another_iterator =
    data_colony.get_iterator_from_pointer(struct_pointer);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is
    correct" &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_iterator(const iterator/const_iterator
    &amp;the_iterator) <b>(slow)</b></code> 
    <p>While colony is a container with unordered insertion (and is therefore
    unordered), it still has a (transitory) order which changes upon any
    erasure or insertion. <i>Temporary</i> index numbers are therefore
    obtainable. These can be useful, for example, when creating a save file in
    a computer game, where certain elements in a container may need to be
    re-linked to other elements in other container upon reloading the save
    file. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    unsigned int index = data_colony.get_index_from_iterator(an_iterator);<br>
    if (index == 2) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_reverse_iterator(const
    reverse_iterator/const_reverse_iterator &amp;the_iterator)
    <b>(slow)</b></code> 
    <p>The same as get_index_from_iterator, but for reverse_iterators and
    const_reverse_iterators. Index is from front of colony (same as iterator),
    not back of colony. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::reverse_iterator r_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    r_iterator = data_colony.rend();<br>
    unsigned int index =
    data_colony.get_index_from_reverse_iterator(r_iterator);<br>
    if (index == 1) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>iterator get_iterator_from_index(const size_type index)
    <b>(slow)</b></code> 
    <p>As described above, there may be situations where obtaining iterators to
    specific elements based on an index can be useful, for example, when
    reloading save files. This function is basically a shorthand to avoid
    typing <code>"iterator it = colony.begin(); colony.advance(it,
    50);"</code>. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    iterator an_iterator = data_colony.insert(struct_instance);<br>
    iterator another_iterator = data_colony.get_iterator_from_index(2);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is
    correct" &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>allocator_type get_allocator()</code> 
    <p>Returns a copy of the allocator used by the colony instance.</p>
  </li>
</ul>
<!-- <h3>Non-member functions</h3> -->
<ul>
  <li><code>template &lt;iterator_type&gt; void advance(iterator_type iterator,
    distance_type distance)</code> 
    <p>Increments/decrements the iterator supplied by the positive or negative
    amount indicated by <i>distance</i>. Speed of incrementation will almost
    always be faster than using the ++ operator on the iterator for increments
    greater than 1. In some cases it may approximate O(1). The iterator_type
    can be an iterator, const_iterator, reverse_iterator or
    const_reverse_iterator.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.begin();<br>
    i_colony.advance(it, 20); </code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type next(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then increments/decrements this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type prev(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then decrements/increments this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it2 =
    i_colony.prev(i_colony.end(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; difference_type distance(const
    iterator_type &amp;first, const iterator_type &amp;last)</code> 
    <p>Measures the distance between two iterators, returning the result, which
    will be negative if the second iterator supplied is before the first
    iterator supplied in terms of it's location in the colony.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);<br>
    colony&lt;int&gt;::iterator it2 = i_colony.prev(i_colony.end(), 20);<br>
    std::cout "Distance: " i_colony.distance(it, it2) std::endl;</code></p>
  </li>
</ul>

<h3>Non-member functions</h3>
<ul>
  <li><code>void swap(colony &amp;A, source &amp;B)</code>
    <p>Swaps colony A's contents with that of colony B (assumes both stacks
    have same element type, allocator type, etc). <br>
    Example: <code style="color: brown">swap(object_colony, other_colony);</code> </p>
  </li>
</ul>


<h2><a id="benchmarks"></a>Benchmarks</h2>

<p style="font-size: 75%"><i>Last updated 8-2-2017 v3.87</i></p>
<ol>
  <li><a href="#testsetup">Test setup</a></li>
  <li><a href="#testdesign">Tests design</a></li>
  <li><a href="#rawperformance">Raw performance benchmarks (against standard
    containers)</a></li>
  <li><a href="#comparitiveperformance">Comparitive performance benchmarks
    (against modified standard containers)</a></li>
  <li><a href="#lowmodification">Low-modification scenario test</a></li>
  <li><a href="#highmodification">High-modification scenario test</a></li>
  <li><a href="#heavyreferencing">Referencing scenario test</a></li>
  <li><a href="#overall">Overall performance conclusions</a></li>
</ol>

<h4><a id="testsetup"></a>Test machine setup</h4>

<p>The test setup is an Intel E8500, 8GB ram, running GCC 5.1 x64 as compiler.
OS is a stripped-back Windows 7 x64 SP1 installation with the most services,
background tasks (including explorer) and all networking disabled. Build
settings are "-O2 -march=native -std=c++11 -fomit-frame-pointer". Results under
MSVC 2015 update 3, on an Intel Xeon E3-1241 (Haswell core) can be viewed <a
href="colony_benchmark_msvc_results.htm">here</a>. There is no commentary for
the MSVC results.</p>

<p>The source code for the benchmarks can be found in the colony page <a
href="http://www.plflib.org/colony.htm#download">downloads</a> section.</p>

<h4><a id="testdesign"></a>General test design</h4>

<p>Tests are based on a sliding scale of number of runs vs number of elements,
so a test with only 10 elements in a container may average 100000 runs to
guarantee a more stable result average, whereas a test with 100000 elements may
only average 10 runs. This tends to give adequate results without overly
lengthening test times. I have not included results involving 'reserve()'
functions as the differences to overall insertion performance were not
adequate.</p>

<p><b>Insertion:</b> is into empty containers for the raw and comparitive
tests, entering single elements at a time. For the 'scenario' tests there is
also ongoing insertion at random intervals. This matches the use case of
colony, where insertion on-the-fly is expected to be one of the driving factors
of usage. Insertion is always at the most performant location for the specific
container, for example front for list, or back for vector.<br>
<b>Erasure:</b> initially takes place in an iterative fashion for the raw
tests, erasing elements at random as we iterate through the container. The
exception to this is the tests involving a remove_if pattern (pointer_deque and
indexed_vector) which have a secondary pass when using this pattern. <br>
<b>Iteration:</b> is straightforward iteration from the start to end of any
containers. Typically there are more runs for iteration than the other tests
due to iteration being a much quicker procedure, so more runs deliver a more
stable average.</p>

<h3><a id="rawperformance"></a>Raw performance tests</h3>

<p>Before we begin measuring colony against containers or container
modifications which do not invalidate links on erasure or insertion, we need to
identify which containers are good candidates for comparison based on raw
performance without regard to linkage invalidation. With that in mind the
following tests compare colony against the main standard library containers.
Tests are carried out on the following types: (a) a 8-bit type ie. char, (b) a
32-bit type ie. int, (c) a 64-bit type ie. double, (d) a small struct
containing two pointers and four scalar types, and (e) a large struct
containing 2 pointers, 4 scalar types, a large array of ints and a small array
of chars.</p>

<p>The first test measures time to insert N elements into a given container,
the second measures the time taken to erase 25% of those same elements from the
container, and the third test measures iteration performance after the erasure
has taken place. Erasure tests avoid the remove_if pattern for the moment to
show standard random-access erasure performance more clearly (this pattern is
explored in the second test). Both linear and logarithmic views of each
benchmark are provided in order to better show the performance of lower element
amounts.</p>

<h4>Insertion Performance</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/char_insertion.png';"
onmouseout="this.src='tests/gcc/colony/raw/char_insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/char_insertion.png';"
src="tests/gcc/colony/raw/char_insertion_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/int_insertion.png';"
onmouseout="this.src='tests/gcc/colony/raw/int_insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/int_insertion.png';"
src="tests/gcc/colony/raw/int_insertion_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/double_insertion.png';"
onmouseout="this.src='tests/gcc/colony/raw/double_insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/double_insertion.png';"
src="tests/gcc/colony/raw/double_insertion_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/small_struct_insertion.png';"
onmouseout="this.src='tests/gcc/colony/raw/small_struct_insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/small_struct_insertion.png';"
src="tests/gcc/colony/raw/small_struct_insertion_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/large_struct_insertion.png';"
onmouseout="this.src='tests/gcc/colony/raw/large_struct_insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/large_struct_insertion.png';"
src="tests/gcc/colony/raw/large_struct_insertion_log.png"><br>


<p>A predictable pattern for all but the large struct test is shown for
insertion:<br>
std::deque dominates insertion, with plf::colony equal after about 100
elements, but then for large structs it's performance completely eclipses
std::deque. This is because libstdc++'s implementation of deque caps the memory
block size at 512 bytes, whereas the large struct in question is ~506 bytes
(depending on platform), meaning it, essentially, becomes a std::list but with
additional overheads. Colony avoids this downfall due to it's memory allocation
pattern of basing memory block sizes on fixed numbers of elements with a growth
factor of 2, not fixed numbers of bytes. std::vector is nearly on a par with
std::deque for very small element types with element numbers greater than a
thousand, but becomes worse and worse the larger the size of the stored type
is, and the fewer stored elements there are.<br>
std::list, std::map and std::multiset all perform poorly by contrast, with the
exception of large structs, where std::list comes in 2nd place to colony.
Overall, plf::colony and std::deque dominate.</p>

<h4>Erase Performance</h4>

<p>Here we forward-iterate over each container and erase 25% of all elements at
random. If (due to the variability of random number generators) 25% of all
elements have not been erased by the end of the container iteration, the test
will reverse-iterate through the container and randomly erase the remaining
necessary number of elements until that 25% has been reached.</p>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/char_erase_25.png';"
onmouseout="this.src='tests/gcc/colony/raw/char_erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/char_erase_25.png';"
src="tests/gcc/colony/raw/char_erase_25_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/int_erase_25.png';"
onmouseout="this.src='tests/gcc/colony/raw/int_erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/int_erase_25.png';"
src="tests/gcc/colony/raw/int_erase_25_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/double_erase_25.png';"
onmouseout="this.src='tests/gcc/colony/raw/double_erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/double_erase_25.png';"
src="tests/gcc/colony/raw/double_erase_25_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/small_struct_erase_25.png';"
onmouseout="this.src='tests/gcc/colony/raw/small_struct_erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/small_struct_erase_25.png';"
src="tests/gcc/colony/raw/small_struct_erase_25_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/large_struct_erase_25.png';"
onmouseout="this.src='tests/gcc/colony/raw/large_struct_erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/large_struct_erase_25.png';"
src="tests/gcc/colony/raw/large_struct_erase_25_log.png"><br>


<p>Across all types plf::colony dominates performance, with std::list coming
close behind. std::deque and std::vector have predictably poor performance as a
remove_if pattern is not being used, as much as 100000x worse than plf::colony
and std::list for large numbers of large types.</p>

<h4>Post-erasure Iteration Performance</h4>

<p>Since data is typically iterated across more than it is erased or inserted,
iteration speed is, for many areas, more important than erase or insertion
performance, despite the fact that it almost always takes factors of ten less
time than either of those two.</p>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/char_iteration.png';"
onmouseout="this.src='tests/gcc/colony/raw/char_iteration_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/char_iteration.png';"
src="tests/gcc/colony/raw/char_iteration_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/int_iteration.png';"
onmouseout="this.src='tests/gcc/colony/raw/int_iteration_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/int_iteration.png';"
src="tests/gcc/colony/raw/int_iteration_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/double_iteration.png';"
onmouseout="this.src='tests/gcc/colony/raw/double_iteration_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/double_iteration.png';"
src="tests/gcc/colony/raw/double_iteration_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/small_struct_iteration.png';"
onmouseout="this.src='tests/gcc/colony/raw/small_struct_iteration_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/small_struct_iteration.png';"
src="tests/gcc/colony/raw/small_struct_iteration_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/raw/large_struct_iteration.png';"
onmouseout="this.src='tests/gcc/colony/raw/large_struct_iteration_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/raw/large_struct_iteration.png';"
src="tests/gcc/colony/raw/large_struct_iteration_log.png"><br>


<p>std::vector and std::deque come in first and second place for most types,
with colony in third place - the only place where this does not occur is for
large structs, where colony dominates std::deque after approximately 20000
elements are inserted. Once again this is due to the structure of deque as
explained in the insertion conclusion above.</p>

<p>For under 1000 elements, std::list is about on par with both std::deque and
std::vector, both of which dominate these tests, with std::vector taking 1st
place. However the number of elements necessary before this effect occurs on
std::list decreases according to how large the stored type is, suggesting that
performance in this case is due to some effect of the cpu cache or
implementation. Querying the GCC mailing list about this resulted in the
following response, which I believe to be accurate due to the correlation
between std::list iteration performance and type size: "I suspect that for
working sets which fit into the first-level cache of the CPU, the simpler
iterators for std::list are faster than std::deque because the additional
memory accesses in std::list are cheaper than the fairly complicated iterator
implementation in std::deque". What this suggests is that for typical programs,
where more than one data set is competing for space in the L1 or L2 caches,
std::list performance will not follow the pattern above and generally will be
poor.</p>

<h4>Raw tests Conclusion</h4>

<p>From the above data we can see that std::list is not a good contendor
against plf::colony, as it has weaker insertion and erase performance, and the
only scenario where it has good iteration performance is where (a) the amount
of data in the container is small enough to fit entirely into the cache and (b)
where that data set is the only data set being operated on by the program in
question, and in fact the computer as a whole. That being a relatively uncommon
case, std::list is not a general contendor.</p>

<p>std::deque is a contendor, having strong insertion performance and excellent
iteration performance but poor non-remove_if erasure performance - however
std::deque invalidates pointers upon erasure, meaning it requires modification
to be used in a way comparable to colony. std::vector is a slightly weaker
contendor, having weak insertion performance and worse non-remove_if erasure
performance than std::deque, however it's iteration performance is always the
best, being entirely contiguous in memory, rather than deque which is only
partially contiguous. std::vector invalidates pointers on both insertion and
erasure, meaning it will also require modification to compare to colony.</p>

<h3><a id="comparitiveperformance"></a>Comparative performance tests</h3>

<p>Colony is primarily designed for scenarios where good
insertion/erasure/iteration performance is required while guarantee'ing linkage
stability for outside elements referring to elements within the container, and
where ordered insertion is unimportant. The two containers from the raw
performance tests which may compare both in performance and usage (after
modification) are std::deque and std::vector. std::list does not meet these
requirements as it has poor insertion and iteration performance. </p>

<h4>pointer_deque and indexed_vector</h4>

<p>Because std::deque does not invalidate pointers to elements upon insertion
to the back or front, we can guarantee that pointers won't be invalidated
during unordered insertion. This means we can use a modification called a
'pointer-to-deque deque', or pointer_deque. Here we take a deque of elements
and construct a secondary deque containing pointers to each element in the
first deque. The second deque functions as an erasable iteration field for the
first deque ie. when we erase we only erase from the pointer deque, and when we
iterate, we iterate over the pointer deque and access only those elements
pointed to by the pointer deque. In doing so we reduce erase times for
larger-than-scalar types, as it is computationally cheaper to reallocate
pointers (upon erasure) than larger structs. By doing this we avoid
reallocation during erasure for the element deque, meaning pointers to elements
within the element deque stay valid.</p>

<p>We cannot employ quite the same technique with std::vector because it
reallocates during insertion to the back of the vector upon capacity being
reached. But since indexes stay valid regardless of a vector reallocates, we
can employ a similar tactic using indexes instead of pointers; which we'll call
an indexed_vector. In this case we use a secondary vector of indexes to iterate
over the vector of elements, and only erase from the vector of indexes. This
strategy has the advantage of potentially lower memory usage, as the bitdepth
of the indexes can be reduced to match the maximum known number of elements,
but it will lose a small amount of performance due to the pointer addition
necessary to utilise indexes instead of pointers. In addition outside objects
refering to elements within the indexed_vector must use indexes instead of
pointers to refer to the elements, and this means the outside object must know
both the index and the container it is indexing; whereas a pointer approach can
ignore this and simply point to the element in question.</p>

<p>We will also compare these two container modifications using a
<i>remove_if</i> pattern for erasure vs regular erasure, by adding an
additional boolean field to indicate erasure to the original stored struct
type, and utilizing two passes - the first to randomly flag elements as being
ready for erasure via the boolean field, the second using the <i>remove_if</i>
pattern. </p>

<h4>vector_bool and deque_bool</h4>

<p>A second modification approach, which we'll call a vector_bool, is a very
common approach in a lot of game engines - a bool or similar type is added to
the original struct or class, and this field is tested against to see whether
or not the object is 'active' (true) - if inactive (false), it is skipped over.
We will also compare this approach using a deque.</p>

<h4>packed_deque</h4>

<p>packed_deque is an implementation of a <a
href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">'packed_array'</a>
as described in the motivation section earlier, but using deques instead of
vectors or arrays. As we've seen in the raw performance benchmarks, (GCC)
libstdc++'s deque is almost as fast as vector for iteration, but about twice as
fast for back insertion and random location erasure. It also doesn't invalidate
pointers upon insertion, which is also a good thing. These things become
important when designing a container which is meant to handle large numbers of
insertions and random-location erasures. Although in the case of a
packed-array, random location erasures don't really happen, the 'erased'
elements just get replaced with elements from the back, so erasure speed is not
as critical, but insertion speed is critical as it will always consume
significantly more CPU time than iteration.</p>

<p>With that in mind my implementation uses two std::deque's internally: one
containing structs which package together the container's element type and a
pointer, and one containing pointers to each of the 'package' structs in the
first deque. The latter is what is used by the container's 'handle' class to
enable external objects to refer to container elements. The pointer in the
package itself in turn points to the package's corresponding 'handle' pointer
in the second deque. This enables the container to update the handle pointer
when and if a package is moved from the back upon an erasure.</p>

<p>Anyone familiar with packed array-style implementations can skip this
paragraph. For anyone who isn't, this is how it works when an element is erased
from packed_deque, unless the element in question is already at the back of the
deque. It:</p>
<ol>
  <li>Uses the pointer within the package to find the 'handle' pointer which
    pointed to the erased element, and adds it to a <a
    href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">free
    list</a>.</li>
  <li>Moves the package at the back of the container to the location of the
    package containing the element being erased.</li>
  <li>Uses the pointer in the package which has just been moved to update the
    corresponding handle pointer, to correctly point to the package's new
    location.</li>
  <li>Pops the back package off the first deque (should be safe to destruct
    after the move - if it's not, the element's implementation is broke).</li>
</ol>

<p>In this way, the data in the first deque stays contiguous and is hence fast
to iterate over. And any handles referring to the back element which got moved
stay valid after the erasure.<br>
</p>

<p>This implementation will not work well under MSVC as MSVC's deque
implementation performs badly.</p>

<h4>Tests</h4>

<p>Since neither indexed_vector nor pointer_deque will have erasure time
benefits for small scalar types, and because game development is predominantly
concerned with storage of larger-than-scalar types, we will only test using
small structs from this point onwards. In addition, we will test 4 levels of
erasure and subsequent iteration performance: 0% of all elements, 25% of all
elements, 50% of all elements, and 75% of all elements. </p>

<h4>Insertion</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/insertion.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/insertion_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/insertion.png';"
src="tests/gcc/colony/comparitive/insertion_log.png"><br>


<p>For insertion plf::colony outperforms the others for greater than 100 and
less than 20000 elements. Below 100 elements it is outperformed by
pointer_deque and deque_bool, and above 20000 elements it is outperformed by
deque_bool. packed_deque consistently comes 4th, and both vector methods
perform poorly by contrast.</p>

<h4>Erasure</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/erase_25.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/erase_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/erase_25.png';"
src="tests/gcc/colony/comparitive/erase_25_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/erase_50.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/erase_50_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/erase_50.png';"
src="tests/gcc/colony/comparitive/erase_50_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/erase_75.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/erase_75_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/erase_75.png';"
src="tests/gcc/colony/comparitive/erase_75_log.png"><br>


<p>Here the gap consistently widens between the candidates as erasure
percentage increases. The two boolean skipfield methods obviously dominate
performance, being the easiest and fastest to implement in terms of erasure.
Above 25% erasure both of the remove_if variants outperform the others, with
packed_deque and colony criss-crossing each other in terms of performance. The
non-remove_if variants of pointer_deque and indexed_vector of course perform
poorly.</p>

<h4>Post-erasure Iteration</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/iteration_0.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/iteration_0_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/iteration_0.png';"
src="tests/gcc/colony/comparitive/iteration_0_log.png"><br>


<p>Colony performs the worst out of the lot for iteration with zero erasures,
with deque_bool coming in slightly worse only for large numbers of elements.
Unsurprisingly packed_deque performs the best out of the lot as this
constitutes pure contiguous iterative performance with no skipfield or
iteration field. While close, the pointer_deque approach has a slight
performance advantage over the indexed_vector.</p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/iteration_25.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/iteration_25_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/iteration_25.png';"
src="tests/gcc/colony/comparitive/iteration_25_log.png"><br>


<p>Now we begin to see the advantage of a jump-counting skipfield over a
boolean skipfield. Because boolean skipfields require branching code to iterate
over, and 25% of all elements being erased represents a large number of cache
misses. Other than that the results are much the same as the 0% test.</p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/iteration_50.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/iteration_50_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/iteration_50.png';"
src="tests/gcc/colony/comparitive/iteration_50_log.png"><br>


<p>At 50% randomised erasures, a CPU's branch prediction cannot work at all,
and so the boolean approaches degrade significantly.</p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/comparitive/iteration_75.png';"
onmouseout="this.src='tests/gcc/colony/comparitive/iteration_75_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/comparitive/iteration_75.png';"
src="tests/gcc/colony/comparitive/iteration_75_log.png"><br>


<p>At this point we can clearly see that the boolean approaches are not useful
in terms of iteration.</p>

<p>Summary: for iteration packed_deque comes 1st, pointer_deque 2nd,
indexed_vector 3rd, colony 4th, vector_bool 5th and deque_bool 6th.</p>

<h3><a id="lowmodification"></a>'Real-world' scenario testing - low
modification</h3>

<p>While testing iteration, erasure and insertion separately can be a useful
tool, they don't tell us how containers perform under real-world conditions, as
under most use-cases we will not be simply inserting a bunch of elements,
erasing some of them, then iterating once over the data. To get more valid
results, we need to think about the kinds of use-cases we may have for
different types of data, in this cas, video-game data.</p>

<p>In this test we simulate the use-case of a container for general video game
objects, actors/entities, enemies etc. Initially we insert a number of small
structs into the container, then simulate in-game 'frames'. We iterating over
container elements every frame, and erase(at random locations)/insert 1% of the
original number of elements for every minute of gametime ie. 3600 frames
assuming 60 frames-per-second. We measure the total time taken to simulate this
scenario for 108000 frames (half an hour of simulated game-time, assuming 60
frames per second), as well as the amount of memory used by the container at
the end of the test. We then re-test this scenario with 5% of all elements
being inserted/erased, then 10%.</p>

<p>With some reluctance I have also included the results for std::list in this
test and the high modification tests, despite the fact that the earlier 'raw'
performance tests show that it is not a contendor for colony, at least in the
same problem domain. This is because some people were not able to relate the
raw performance test outcomes to the expected outcomes of subsequent tests. By
contrast there is less point again in including std::map/std::multiset for
these tests, as their raw iteration, erasure, and insertion outcomes were much
worse than other containers.</p>

<p></p>

<p><i>Click images or hover over to see results at linear scale instead</i></p>

<h4>Performance results</h4>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_1.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_1.png';"
src="tests/gcc/colony/general_use/per_minute_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_5.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_5.png';"
src="tests/gcc/colony/general_use/per_minute_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_10.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_10.png';"
src="tests/gcc/colony/general_use/per_minute_10_log.png"><br>


<p></p>

<h4>Memory results</h4>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_mem_1.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_mem_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_mem_1.png';"
src="tests/gcc/colony/general_use/per_minute_mem_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_mem_5.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_mem_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_mem_5.png';"
src="tests/gcc/colony/general_use/per_minute_mem_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_minute_mem_10.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_minute_mem_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_minute_mem_10.png';"
src="tests/gcc/colony/general_use/per_minute_mem_10_log.png"><br>


<h3><a id="highmodification"></a>'Real-world' scenario testing - high
modification</h3>

<p>Same as the previous test but here we erase/insert 1% of all elements
per-frame instead of per 3600 frames, then once again increase the percentage
to 5% then 10% per-frame. This simulates the use-case of continuously-changing
data, for example video game bullets, decals, quadtree/octree nodes,
cellular/atomic simulation or weather simulation.</p>

<h4>Performance results</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_1.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_1.png';"
src="tests/gcc/colony/general_use/per_frame_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_5.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_5.png';"
src="tests/gcc/colony/general_use/per_frame_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_10.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_10.png';"
src="tests/gcc/colony/general_use/per_frame_10_log.png"><br>


<p></p>

<h4>Memory results</h4>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_mem_1.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_mem_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_mem_1.png';"
src="tests/gcc/colony/general_use/per_frame_mem_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_mem_5.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_mem_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_mem_5.png';"
src="tests/gcc/colony/general_use/per_frame_mem_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/general_use/per_frame_mem_10.png';"
onmouseout="this.src='tests/gcc/colony/general_use/per_frame_mem_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/general_use/per_frame_mem_10.png';"
src="tests/gcc/colony/general_use/per_frame_mem_10_log.png"><br>


<p>Obviously if you are doing a lot of referencing into a packed_deque from
outside objects, you may encounter some speed problems due to the dereferencing
system - which the next test will cover. On the other hand, if you are mainly
iterating over unordered data, erasing occasionally, and only ever referring
<i>outwards from</i> elements within the packed_deque, it will be an ideal
solution.</p>

<h3><a id="heavyreferencing"></a>'Real-world' scenario-testing: referencing
with interlinked containers</h3>

<p>In order to completely test plf::colony against a packed-array-style
implementation, it is necessary to measure performance while exploiting both
container's linking mechanisms - for colony this is pointers or iterators, for
a packed array this is a handle, or more specifically a pointer to a pointer
(or the equivalent index-based solution). Because that additional dereferencing
is a performance loss and potential cache miss, any test which involves a large
amount of inter-linking between elements in multiple containers should lose
some small amount of performance when using a packed_deque instead of a colony.
Since games typically have high levels of interlinking between elements in
multiple containers (as described in the motivation section), this is relevant
to performance concerns.</p>

<p>Consequently, this test utilizes four instances of the same container type,
each containing different element types:</p>
<ol>
  <li>A 'collisions' container (which could represent collision rectangles
    within a quadtree/octree/grid/etc)</li>
  <li>An 'entities' container (which could representing general game objects)
    and</li>
  <li>Two subcomponent containers (these could be sprites, sounds, or anything
    else).</li>
</ol>
<img src="referencer_test.gif" alt="test class diagram"> 

<p>This is actually a very low number of inter-related containers for a game,
but we're reducing the number of components in this case just to simplify the
test. Elements in the 'entities' container link to elements in all three of the
other containers. In turn, the elements in the collisions container link back
to the corresponding elements in the entities container. The subcomponent
containers do not link to anything.</p>

<p>In the test, elements are first added to all four containers and interlinked
(as this is a simplified test, there's a one-to-one ratio of entity elements to
'collision' and subcomponent elements). The core test process after this point
is similar to the modification scenarios tested earlier: we iterate over the
entity container once every frame, adding a number from both the entities and
subcomponents to a total. We also erase a percentage of entities per-frame (and
their corresponding subcomponents and collision blocks) - similar to the
earlier tests. </p>

<p>However during each frame we also iterate over the 'collisions' container
and erase a percentage of these elements (and their corresponding entities and
subcomponents) at random as well. This could be seen as simulating entities
being removed from the game based on collisions occurring, but is mainly to
test the performance effects of accessing the subcomponents via a chain of
handles versus a chain of pointers. Then, again during each frame, we re-add a
certain number of entities, collision blocks and subcomponents back into the
containers based on the supplied percentage value. Since both colony and
packed_deque essentially re-use erased-element memory locations, this tests the
efficacy of each containers mechanism for doing so (packed_deque's move-and-pop
+ handle free-list, versus colony's stack + skipfield). </p>

<p>Since neither container will grow substantially in memory usage over time as
a result of this process, a longer test length is not necessary like it was for
the earlier modification scenario-testing with indexed_vector and
pointer_deque. Testing on both plf::colony and plf::packed_deque showed that
both of their test results increased linearly according to the number of
simulated frames in the test (indexed_vector and pointer_deque have a more
exponential growth). Similarly to the modification tests above, we will start
with 1% of all elements being erased/inserted per 3600 frames, then 5% and 10%,
then move up to 1% of all elements being erased/inserted per-frame, then 5%
per-frame, then 10% per-frame.</p>

<h4>Performance results</h4>

<p><i>Click images or hover over to see results at linear scale instead</i></p>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_1.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_1.png';"
src="tests/gcc/colony/referencer/per_minute_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_5.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_5.png';"
src="tests/gcc/colony/referencer/per_minute_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_10.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_10.png';"
src="tests/gcc/colony/referencer/per_minute_10_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_1.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_1.png';"
src="tests/gcc/colony/referencer/per_frame_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_5.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_5.png';"
src="tests/gcc/colony/referencer/per_frame_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_10.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_10.png';"
src="tests/gcc/colony/referencer/per_frame_10_log.png"><br>


<p>As we can see from the performance results, at low levels of modification
packed_deque has a small performance advantage over colony, until about 9000
elements. After 9000 elements, colony has a larger performance advantage. And
the higher the level of modification, the fewer elements there have to be in
the containers before colony has an advantage. At 1% modification per frame,
only 200 elements are needed, while at 5% per-frame and above, colony always
has a strong advantage.</p>

<h4>Memory results</h4>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_mem_1.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_mem_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_mem_1.png';"
src="tests/gcc/colony/referencer/per_minute_mem_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_mem_5.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_mem_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_mem_5.png';"
src="tests/gcc/colony/referencer/per_minute_mem_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_minute_mem_10.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_minute_mem_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_minute_mem_10.png';"
src="tests/gcc/colony/referencer/per_minute_mem_10_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_mem_1.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_mem_1_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_mem_1.png';"
src="tests/gcc/colony/referencer/per_frame_mem_1_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_mem_5.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_mem_5_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_mem_5.png';"
src="tests/gcc/colony/referencer/per_frame_mem_5_log.png"><br>
<img alt="test result graph"
onmouseover="this.src='tests/gcc/colony/referencer/per_frame_mem_10.png';"
onmouseout="this.src='tests/gcc/colony/referencer/per_frame_mem_10_log.png';"
style="cursor: pointer;"
onclick="this.src='tests/gcc/colony/referencer/per_frame_mem_10.png';"
src="tests/gcc/colony/referencer/per_frame_mem_10_log.png"><br>


<p>As we can see the memory results don't really change between different
levels of modification - packed_deque always has a small advantage over colony
in terms of memory usage. The memory difference could be mitigated somewhat by
setting a smaller maximum group size for colony, but this will likely come at
an expense of speed.</p>

<h3><a id="overall"></a>Overall Performance Conclusions</h3>

<p>For situations where unordered, often-inserted/erased content is required,
colony provides a convenient solution, while also outperforming the
alternatives for the most part. Where modification rates and the number of
elements are low, a packed-array-style structure like packed_deque may be your
best solution both in terms of performance and memory usage. However once the
numbers of elements and rates of modification begin to rise, a colony shines
forth. In addition, a packed array will be affected adversely when the type is
larger or non-trivially movable, due to the necessity of moving elements from
the back when erasing.</p>

<p>Using a boolean skipfield in combination with a vector or deque is of course
a no-go, due to it's poor iteration performance once the number of erasures
increases. Similarly, using an erasable iteration field as was used with
indexed_vector and pointer_deque results in both wasteful memory consumption
and poor performance once the number of modifications or elements becomes too
high.</p>

<p>In short, use a packed-array where both the rate of modification is &lt;=
10% of all elements per 3600 iterations over data and the number of elements is
&lt;= 9000, or if external object access to container elements via the
dereferencing system is uncommon, or if all memory is at a premium. In all
other cases involving unordered data, use colony.</p>

<h2><a id="faq"></a>Frequently Asked Questions</h2>
<ol>
  <li><h4>TLDR, what is a colony?</h4>
    <p>A combination of a linked-list of increasingly-large memory blocks with
    metadata, combined with a jump-counting skipfield, combined with an
    erased-element memory-location stack for later reinsertions, resulting in a
    std::-styled C++ template data container with positive performance
    characteristics while maintaining pointer stability to container
    elements.</p>
  </li>
  <li><h4>Where is it worth using a colony in place of other std::
    containers?</h4>
    <p>As mentioned, it is worthwhile for performance reasons in situations
    where the order of container elements is not important and:</p>
    <ol type="a">
      <li>Insertion order is unimportant</li>
      <li>Insertions and erasures to the container occur frequently in
        performance-critical code, <i><b>and</b></i> </li>
      <li>Links to non-erased container elements may not be invalidated by
        insertion or erasure.</li>
    </ol>
    <p>Under these circumstances a colony will generally out-perform other
    std:: containers. In addition, because it never invalidates pointer
    references to container elements (except when the element being pointed to
    has been previously erased) it may make many programming tasks involving
    inter-relating structures in an object-oriented or modular environment much
    faster, and could be considered in those circumstances.</p>
  </li>
  <li><h4>What are some examples of situations where a colony might improve
    performance?</h4>
    <p>Some ideal situations to use a colony: cellular/atomic simulation,
    persistent octtree/quadtree, general game entities or destructible-objects
    in a video game, particle physics, anywhere where objects are being created
    and destroyed continuously. Also, anywhere where a vector of pointers to
    dynamically-allocated objects or a std::list would typically end up being
    used in order to preserve object references but where order is
    unimportant.</p>
  </li>
  <li><h4>What situations should you explicitly <i>not</i> use a colony
    for?</h4>
    <p>A colony should not be used as a stack, ie. erasing backwards from the
    back, and then filling, then erasing from the back, etc. In this case you
    should use a stack ie. plf::stack, std::vector or std::deque. The reason is
    that erasing backwards sequentially creates the greatest time complexity
    for skipfield updates, as does reinserting to the start of a
    sequentially-erased skipblock (which is what stack usage will entail). This
    effect is mitigated somewhat if an entire group is erased, in which case it
    is released to the OS and subsequent insertions will not be updating
    skipfields but simply pushing to back, but you'd still incur the skipfield
    update cost during erasure.</p>
    <p>In general you should avoid erasing sequentially during reverse
    iteration except where absolutely neccessary - the skipfield format is
    optimized for forward-iteration and forward sequential erasure.</p>
  </li>
  <li><h4>What are the time complexities for general operations?</h4>
	<p>Insert (single): O(1) amortised unless prior erasures have occurred in theusage lifetime of the colony instance. If prior erasures have occurred,updating the skipfield may require a memmove operation, which creates avariable time complexity depending on the range of skipfield needing to becopied (though in practice this will resolve to a singular raw memory blockcopy in most scenarios). This is O(random) with the range of the random numberbeing between O(1) and O(std::numeric_limits&lt;skipfield_type&gt;::max() - 2).Average time complexity varies based on erasure pattern, but with a randomerasure pattern it's closer to O(1) amortized.</p><p>Insert (multiple): O(N) unless prior erasures have occurred. See
	Insertion(single) for rules in this case.</p>
	
	<p>Erase (single): If erasures to elements consecutive with the element being
	erased have not occurred, or only consecutive erasures before the element being
	erased have occurred, O(1) amortised. If consecutive erasures after the element
	being erased have occurred, updating of the skipfield requires a memmove
	operation or vectorized update of O(n) complexity, where n is the number of
	consecutive erased elements after the element being erased. This is O(random)
	with the range of the random number being between from 1 and
	std::numeric_limits&lt;skipfield_type&gt;::max() - 2. Average time complexity
	varies based on erasure pattern, but with a random erasure pattern it's closer
	to O(1) amortized.</p>
	
	<p>Erase (multiple): ~O(log N).</p>
	
	<p>std::find: O(n)</p>
	
	<p>Iterator operations: <br>
	++ and -- : O(1) amortized <br>
	begin()/end(): O(1) <br>
	advance/next/prev: between O(1) and O(n), depending on current location, end
	location and state of colony. Average ~O(log N).</p>
  </li>
  <li><h4>If the time complexities of the insert/erase functions are (kind of)
    O(random, ranged), why are they still quick?</h4>
    <p>The skipfield for each group is contiguous and separate from the
    skipfields for other groups, and so fits into the cache easily (unless the
    skipfield type is changed); thus any changes to it can occur quickly - time
    complexity is, actually, no indicator of performance on a modern CPU.</p>
    <p>Colony now also uses memmove instead of iterative updates for all but
    one of the insert/erase operations, which again decreases performance cost.
    In modern implementations, memmove will typically be implemented in memory
    chunks, which may reduce further the time complexity. There is one
    situation in erase which does not use memmove, a rarer case where an
    element is erased and is surrounded on both sides by consecutive erased
    skipfield nodes. In this case it isn't actually possible to update the
    skipfield using memmove because the requisite numbers do not already exist
    in the skipfield and cannot be copied, so it is implemented as a vectorized
    update instead. But again due to a low amount of branching the actual time
    taken for the update is quite quick, regardless of the number of nodes that
    need to be updated.</p>
  </li>
  <li><h4>Is it similar to a deque?</h4>
    <p>A deque is reasonably dissimilar to a colony - being a double-ended
    queue, it requires quite a bit of a different internal framework. It
    typically uses a vector of memory blocks, whereas the colony implementation
    uses a linked list of memory blocks, essentially. A deque can't technically
    use a linked list of memory blocks because it will make some random_access
    iterator operations (eg. + operator) non-O(1). In addition, being a
    double-ended queue makes having a growth factor for memory blocks
    problematic because the rules for growth at each end of the queue become
    difficult to implement in a way which increase performance. And in fact, if
    you were to be remove memory blocks from within a deque, you could not
    utilize a growth factor because this would make the "+" iterator operator
    impossible to implement in O(1) time (as you would not be able to ascertain
    the size for each memory block without inspecting them all).</p>
    <p>A deque and colony have no comparable performance characteristics except
    for insertion (for a decent deque implementation). Deque erasure
    performance varies wildly depending on the implementation compared to
    std::vector, but is generally similar to vector erasure performance. A
    deque also invalidates pointers to subsequent container elements when
    erasing elements, which a colony does not.</p>
  </li>
  <li><h4>What are the thread-safe guarantees?</h4>
    <p>Unlike a std::vector, a colony can be read from and written to at the
    same time, however it cannot be iterated over and written to at the same
    time. If we look at a (non-concurrent implementation of) std::vector's
    threadsafe matrix, to see which basic operations can occur at the same
    time, it reads as follows (please note push_back() is the same as insertion
    in this regard):</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>std::vector</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, multiple reads and iterations over iterators can happen
    simultaneously, but the invalidation caused by insertion/push_back and
    erasure means those operations cannot occur at the same time as anything
    else.</p>
    <p>Colony on the other hand does not invalidate pointers/iterators to
    non-erased elements during insertion and erasure, resulting in the
    following matrix:</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>plf::colony</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Mostly</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>Yes</td>
          <td>Mostly</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, reads may occur at the same time as insertions and
    erasures (provided that the element being erased is not the element being
    read), multiple reads and iterations may occur at the same time, but
    iterations may not occur at the same time as an erasure or insertion, as
    either of these may change the state of the skipfield which's being
    iterated over. Erasures will not invalidate iterators unless the iterator
    points to the erased element. Note that iterators pointing to end() may be
    invalidated by insertion.</p>
    <p>So, colony could be considered more inherently threadsafe than a
    (non-concurrent implementation of) std::vector, but still has some areas
    which would require mutexes or atomics to navigate in a multithreaded
    environment.</p>
  </li>
  <li><h4>Any pitfalls to watch out for?</h4>
    <ol type="1">
      <li>Because erased-element memory locations will be reused by
        <code>insert()</code> and <code>emplace()</code>, insertion position is
        essentially random unless no erasures have been made, or an equal
        number of erasures and insertions have been made.</li>
      <li>For architectural reasons, reserve can only reserve a number of
        elements up to the maximum bit-depth of the skipfield type (65535
        unless an alternative type is specified in the constructor).</li>
    </ol>
  </li>
  <li><h4>Am I better off storing iterators or pointers to colony elements?</h4>
    <p>My testing so far indicates that storing pointers and then using
    <code>get_iterator_from_pointer()</code> when or if you need to do an erase
    operation on the element being pointed to, is more performant than storing
    iterators and performing erase directly on the iterator.</p>
  </li>
  <li><h4>Any special-case uses?</h4>
    <p>In the special case where many, many elements are being continually
    erased/inserted in realtime, you might want to experiment with limiting the
    size of your internal memory groups in the constructor. The form of this is
    as follows:<br>
    <code>plf::vector&lt;object&gt; a_vector;<br>
    a_vector.change_group_sizes(500, 5000);</code><br>
    where the first number is the minimum size of the internal memory groups
    and the second is the maximum size. Note these can be the same size,
    resulting in an unchanging group size for the lifetime of the colony
    (unless <code>change_group_sizes</code> is called again or operator = is
    called).<br>
    One reason to do this is that it is slightly slower to pop an element
    location off the internal memory position recycling stack, than it is to
    insert a new element to the end of the colony (the default behaviour when
    there are no previously-erased elements). If there are any erased elements
    in the colony, the colony will recycle those memory locations, unless the
    entire group is empty, at which point it is freed to memory. So if a group
    size is large and many, many erasures occur but the group is not completely
    emptied, (a) the number of erased element locations in the recycling stack
    could get very large, resulting in a detriment to performance and (b)
    iteration performance will suffer. In that scenario you may want to run a
    benchmark limiting the minimum/maximum sizes of the groups, and tune it
    until you find optimal usage.</p>
    <p>Please note that the the fill, range and initializer-list constructors
    can also take group size parameters, making it possible to construct filled
    colonies using custom group sizes.</p>
  </li>
  <li><h4>What is colony's Abstract Data Type (ADT)?</h4>
    <p>While I am happy to be proven wrong I suspect colony is it's own
    abstract data type. Some have suggested it is most similar to a multiset or
    bag, which is probably true, but from my perspective a bag or multiset
    utilizes key values. Colony does not utilize key values, is searchable and
    sortable, but does not give the sort of functionality one would find in a
    bag (for example counting the number of times a specific value occurs).
    Others have suggested a deque, but actually there are three necessary
    aspects to colony which make it function as it does, and which define any
    implementation:</p>
    <ol>
      <li>A multiple-memory-block based allocation pattern which allows for the
        removal of memory blocks when they become empty of elements.</li>
      <li>A skipfield to indicate erasures instead of reallocating elements,
        the iteration of which should typically not necessitate the use of
        branching code.</li>
      <li>A mechanism for storing erased element locations to allow for reuse
        of erased element memory space upon subsequent insertion.</li>
    </ol>
    <p>In the case of my particular colony implementation I utilize a <a
    href="chained_group_allocation_pattern.htm">chained-group memory allocation
    pattern</a> because it appears to have better performance than the
    alternatives, arguably though this could be any multiple-memory-block
    allocation strategy. For the skipfield I utilize the <a
    href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> but if a more efficient skipfield implementation were
    available for a given platform, that could be used. While it is preferable
    that any skipfield used not utilize branching code - as a common boolean
    skipfield does - because of the performance detriment caused by this, it is
    possible there could be a computer architecture where the cost of branching
    is much lower. The main necessity is that the skipfield enables O(1) ++ and
    -- operations (otherwise iterators cannot be valid within the standard).
    For the stack I am using a reduced internal version of <a
    href="stack.htm">plf::stack</a> because based upon benchmarks this approach
    to stacks is more efficient than the current standard library alternatives.
    But again, if a more efficient alternative were found it could be used
    instead.</p>
    <p>If we look at a deque, the only aspect out of those three that it
    shares, is (1) - utilizing a multiple-memory-block allocation pattern.
    Which isn't a strong association. If we look at a multiset, an unordered
    one could be implemented on top of a colony utilizing an additional hash
    table, and it would be more efficient than the current multiset
    implementations as shown in the GCC and MSVC benchmarks. But the necessity
    to add something to make it a multiset, ie. to take and store key values,
    means colony is probably not a multiset, and probably it's own abstract
    data type.</p>
  </li>
  <li><h4>Exception Guarantees?</h4>
    <p>All operations which allocate memory have strong exception guarantees
    and will roll back if an exception occurs, except for operator = which has
    a basic exception guarantee (see below). For colony, iterators are bounded
    by asserts in debug mode, but unbounded in release mode, so it is possible
    for an incorrect use of an iterator (iterating past end(), for example) to
    trigger an out-of-bounds memory exception. These are the only two areas
    where exceptions can occur.</p>
    <p>The reason why operator = only has a basic guarantee is they do not
    utilize the copy-swap idiom, as the copy-swap idiom significantly increases
    the chance of any exception occuring - this is because the most common way
    an exception tends to occur during a copy operation is due to a lack of
    memory space, and the copy-swap idiom doubles the memory requirement for a
    copy operation by constructing the copy before destructing the original
    data. This is doubly innappropriate in game development, which colony has
    been initially for, where memory constraints are often critical and the
    runtime lag from memory spikes can cause detrimental game performance. So
    in the case of colony if a non-memory-allocation-based exception occurs
    during copy, the = operators will have already destructed their data, so
    the containers will be empty and cannot roll back - hence they have a basic
    guarantee, not a strong guarantee.</p>
  </li>
  <li><h4>Iterators not following rule of zero?</h4>
    <p>It was found under GCC and clang that the high-modification scenario
    benchmarks suffered a 11% overall performance loss when iterator copy and
    move constructors/operators where not explicitly defined, possibly because
    GCC did not know to vectorise the operations without explicit code or
    because the compiler implemented copy/swap idiom instead of simply copying
    directly. No performance gain was found under any tests when removing the
    copy and move constructors/operators.</p>
  </li>
  <li><h4>Why must groups be removed when empty?</h4>
    <p>Two reasons:<br>
    1. If groups aren't removed then iterator ++ and -- operations become
    non-O(1) for time complexity, which makes them illegal according to the C++
    standard. At the moment they are O(1) amortised, typically one update for
    both skipfield and element pointers, but two if a skipfield jump takes the
    iterator beyond the bounds of the current group and into the next group.<br>
    If there are multiple empty groups in a row, ++ iteration essentially
    becomes O(random) because each group will require an op to check for
    emptiness and to jump to the next. Essentially you get the same scenario as
    you do with a boolean skipfield.<br>
    2. Performance. Iterating over empty groups is slower than them not being
    present, and pushing to the back of the colony is faster than recycling
    memory locations. When a group is removed it's recyclable memory locations
    are also removed from the stack, hence subsequent insertions are also
    faster.</p>
  </li>
  <li><h4>Why use a stack instead of a free list for erased location
    storage?</h4>
    <p>Two reasons:</p>
    <ol>
      <li>Colony elements are not guaranteed to be of sufficient size (32-bit
        on x86, 64-bit or greater on other architectures) to store a pointer.
        For smaller types and 64-bit pointers, a free list union would end up
        wasting more space than a 16-bit skipfield. While the use-cases in
        games indicate larger-than-scalar types, there has been some interest
        and indication of usefulness from the high-performance-computing and
        storage domains, and I cannot predict their data patterns or usage.</li>
      <li>A free list will likely incur a significant number of cache misses
        and subsequent jitter when a colony memory block is freed to the OS.
        With a stack the erased locations are in contiguous memory space, so it
        is extremely fast and cache-friendly to process the stack and remove
        erased locations belonging to the memory block being freed. On the
        other hand with a free list, removing the erased locations involves
        iterating through the list - which will most likely skip randomly
        throughout the colony blocks, involving many cache misses - in order to
        locate the nodes belonging to the erased memory block and joining
        previous nodes to the next non-erased-block locations.</li>
    </ol>
    <p>In short, it's probably not an effective solution in this case.</p>
  </li>
  <li><h4>Why use three pointers for iterators rather than a group pointer,
    single index and then dereferencing?</h4>
    <p>It's faster. In attempting on two separate occasions to switch to an
    index-based iterator approach, utilizing three separate pointers was
    notably faster.</p>
  </li>
  <li><h4>Group sizes - what are they based on, how do they expand, etc</h4>
    <p>Group sizes start from the minimum size defined either by the default (8
    elements, or larger if the type stored is small) or by the programmer (with
    a minimum of 3 elements). Subsequent group sizes then increase the <i>total
    capacity</i> of the colony by a factor of 2 (so, 1st group 8 elements, 2nd
    8 elements, 3rd 16 elements, 4th 32 elements etcetera) until the maximum
    group size is reached. The default maximum group size is the maximum
    possible number that the skipfield bitdepth is capable of representing
    (std::numeric_limits&lt;Skipfield_type&gt;::max()). By default the
    skipfield bitdepth is 16 so the maximum size of a group is 65535 elements.
    However the skipfield bitdepth is also a template parameter which can be
    set to any unsigned integer - unsigned char, unsigned int, Uint_64, etc.
    Unsigned short (guaranteed to be at least 16 bit, equivalent to C++11's
    uint_least16_t type) was found to have the best performance in real-world
    testing due to the balance between memory contiguousness, memory waste and
    the restriction on skipfield update time complexity. Initially the design
    also fitted the use-case of gaming better (as games tend to utilize lower
    numbers of elements than some other fields), as that was the primary
    development field at the time.</p>
  </li>
  <li><h4>Why store a size member for each group when this can be obtained via
    <code>reinterpret_cast&lt;element_pointer_type&gt;(skipfield) -
    elements</code>?</h4>
    <p>Because it's faster. While it can be obtained that way, having it
    precalculated gives a small but significant benefit. And it's only an
    additional 16 bits per group in most cases.</p>
  </li>
</ol>
<br>
<br>


<h2><a id="version"></a>Version history</h2>
<ul>
  <li>2017-03-28: v3.88 - Correction to emplace. Corrections to default constructor to allow for empty initialization lists. Some standards
    compliance updates and corrections to noexcept statuses. skipfield_type is now a publicly-accessable member typedef. get_group_sizes() is now available. Allocator-extended copy and move constructors added. get_allocator() added. swap(colony &A, colony &B) is now non-member and non-friend.</li>
  <li>2017-02-08: Update and corrections to benchmark code and test
  results.</li>
  <li>2016-12-10: v3.87 - Optimized and corrected range erase. Documentation
    updated.</li>
  <li>2016-11-19: v3.86 - Performance improvements for low numbers of scalar
    types. Minor optimizations for fill-constructor and initializer-list
    constructor. Corrections to advance.</li>
  <li>2016-11-12: v3.83 - Minor optimizations. Edge-case corrections for
    advance functions and copy constructor. Optimizations to
    get_index_from_iterator, get_iterator_from_pointer, distance, advance.
    Advance now correctly bounds to rbegin and rend for reverse iterators.
    Warning removal for test suite.</li>
  <li>2016-11-1: v3.81 - Optimizations to insert functions. Corrections to
    fill-insert/fill-construct functions. Minor correction to internal stack
    copy constructor. Some function and comment tidyup. Moved referencer test
    code out from plf_bench.h to individual test files due to MSVC's forward
    declaration bug (referencer tests not possible with MSVC for this reason).
    Possible edge-case out-of-bounds memory access for insert removed.
    Benchmarks updated.</li>
  <li>2016-10-27: v3.80 - Further optimizations. Removed a potential memory
    leak which would only occur upon exception-based state rollback within
    insert functions. Update to benchmark suite, addition of packed_deque
    container and associated tests.</li>
  <li>2016-10-15: v3.76 - Removed potential memory leak in internal stack
    mechanism.</li>
  <li>2016-10-14: v3.75 - Added get_index_from_reverse_iterator(). Further
    optimization (and one minor correction) of the reduced_stack storage
    mechanism , leading to an 8% performance increase in general_use benchmarks
    for small structs. Additional minor optimization for C++03. Some code
    comment tidyup.</li>
  <li>2016-10-10: v3.73 - change_group_size functions no longer copy-construct
    into a new colony unless the stack is not empty, and either min_group_size
    is larger than the smallest group in the stack, or max_group_size is
    smaller than the largest group in the stack. Correction to
    change_group_sizes code (was clearing erased locations unnecessarily).
    Reinitialize function added, which supports the changing of group sizes for
    colonies of non-copy-constructible element types. Emplace changed to no
    longer require move semantics, which enables the use of
    non-move-constructible/non-copy-constructible types with colony (example:
    anything containing a std::mutex). Minor correction to colony test suite
    under C++03.</li>
  <li>2016-10-04: v3.72 - minor fix to erase.</li>
  <li>2016-10-03: v3.71 - Replaced all but one vectorizing skipfield update
    with memmove ops for greater performance. Colony is no longer dependent on
    plf::stack, now has it's own reduced-functionality internal structure.
    TLDR, slightly faster, slightly faster build time &amp; slightly less
    memory use. Colony and stack are no longer friends :( (aw). Updated
    documentation. Stack separated out of colony package and test suite and
    vice-versa. Added functions to convert element pointer to iterator, and to
    convert iterator to index and vice-versa. Removed pointer-based erase
    function (use get_iterator_from_pointer() instead and call erase() with the
    resultant iterator). Minor update to distance, advance, prev and next
    functions. Benchmark suite updated.</li>
  <li>2016-09-02: v3.61 - Slight performance improvement for general-use-cases
    for colony, small performance/usability improvements in benchmark suite.
    Tweak for MSVC2010 performance. Correction to stack emplace.</li>
  <li>2016-08-24: v3.6 - 8 percent speedup on iteration, vs v3.55, for colony
    with larger-than-scalar types. Performance increases and minor corrections
    in benchmark suite.</li>
  <li>2016-08-20: v3.55 - Updates to benchmark suite - now uses a faster
    xorshift-type rand generator and a fast_mod function, test differences
    between containers more obvious now. Memory approximation also now outside
    of main loops, test cases updated for general_use test. Entirely new
    test-case function. Minor performance enhancements to
    insert/erase/operator++ for colony + code tidy-up. Minor warning removal
    for test suite.</li>
  <li>2016-08-04: v3.51 - Correction to move-insert courtesy of Peet Nick.
    Removal of end-block edge-case scenario code, as it was found to be of such
    low statistical significance as to be useless. The fix increased memory use
    in the scenario of the edge case which might be it's own problem in most
    scenarios. To get around the edge case, if it occurs in a given context, an
    allocator approach would be most appropriate. Update to benchmark
  suite.</li>
  <li>2016-07-19: v3.5 - Colony now accepts a template parameter for the
    skipfield type. This enables the use of, for example, unsigned char as the
    skipfield type. The bitdepth of the unsigned integer also defines the
    default maximum size of colony groups. The benchmark suite has been updated
    with memory measurements for the general_use tests. General_use tests
    changed to percentage-based tests. Internal erased location stack now
    stores only element pointers, not full iterators. Storing just the pointer
    and having to reconstruct the iterator slows down reinsertion after an
    erase, but speeds up the erase itself and results in an overall performance
    improvement, as well as less memory consumption. Slight improvement for
    fill-insert. Sanity-checks for range-insert and initializer-list-insert
    implemented. Minor fix to C++03 support in benchmark suite.</li>
  <li>2016-07-4: v3.35 - Another compliance fix for benchmark suite in clang,
    courtesy of Arthur O'Dwyer.</li>
  <li>2016-07-3: v3.34 - Minor warning removal for test suite. Performance
    improvement for colony edge-case scenario where a single element is
    inserted and then erased repeatedly, and where the insertion point happens
    to be at the end of a memory block.</li>
  <li>2016-07-1: v3.33 - Empty destructors/constructors removed in iterators.
    Small compliancy fixes in both colony and benchmark suite. Thanks to Arthur
    O'Dwyer for this update.</li>
  <li>2016-06-25: v3.31 - Colony iterators no longer inherit from std::iterator
    and implement the required typedefs themselves. Code tidyup and minor
    changes. Default of 1 implemented for prev/next.</li>
  <li>2016-06-17: v3.30 - Correction to colony range constructor. Corrections
    to advance() asserts.</li>
  <li>2016-06-15: v3.29 - Support for stateful allocators added, to both colony
    and stack. More generic solution applied for preventing calls for
    fill-insert to be matched by range insert template.</li>
  <li>2016-06-14: v3.25 - Edge-case corrections to colony's clear(),
    range-insert and fill-insert functions. Minor performance improvement in
    erase edge-case. Removed older (colony-specific) range insert. Simplified
    constructors.</li>
  <li>2016-06-12: v3.22 - Range, fill and initializer-list based insert()'s and
    constructors now implemented in colony. Bugfix for Microsoft compilers.
    Warnings fix for clang. Reinitialize functions removed, replaced with
    change_group_sizes(), change_minimum_group_size() and
    change_maximum_group_size().</li>
  <li>2016-06-11: v3.19 - Minor bugfix to plf::stack.</li>
  <li>2016-06-9: v3.18 - Corrections to colony and stack C++11 typedefs. Some
    code tidyup. Minor code corrections. Simplified reserve() and
    shrink_to_fit() functions. Added trim_trailing_groups() function to stack.
    Minor performance improvements.</li>
  <li>2016-05-31: v3.16 - Corrections to colony and stack reserve(). Some code
    tidyup. Correction to test suite.</li>
  <li>2016-05-30: v3.15 - Colony and stack are now compliant with C++11 and
    C++14 <a
    href="http://en.cppreference.com/w/cpp/concept/Container">container</a>
    concepts. Vectorized some erasure and insertion operations resulting in
    better overall performance in some scenarios. Corrected edge case in
    reverse iteration operator ++. All iterators now bounded by asserts in
    debug mode. Correction to capacity functions.</li>
  <li>2016-05-26: v3.14 - Added swap (std::swap worked fine without it, mainly
    required for standards compliance, also is exception-safe) and max_size()
    functions to stack and colony.</li>
  <li>2016-05-24: v3.13 - erase(element_pointer) added to colony. This enables
    erasure via a colony element's pointer, rather than it's iterator. Slightly
    slower than iterator-based erasure as a lookup has to be done for the
    colony element's group. Update to test suite.</li>
  <li>2016-05-19: v3.11 - Fix for colony shrink_to_fit(), added special case to
    stack copy constructor for when source size &gt; max_group_size, colony and
    stack constructors now explicit. Update to test suite.</li>
  <li>2016-05-12: v3.10 - Both stack and colony no longer preallocate upon
    construction, only upon first insertion. Minor assert bugfix in colony.
    shrink_to_fit(), reserve() and capacity() functions added to both classes.
    Some code cleanup, corrections for C++03 and minor optimizations.</li>
  <li>2016-04-28: v3.05 - Removal of compiler-specific iteration code,
    resulting in 8% speedup for larger-than-scalar type iteration, 6% slowdown
    for scalar-type iteration, under GCC x64. MSVC unaffected by change.
    Addition of benchmark suite. Correction to plf_nanotimer under
  linux/bsd.</li>
  <li>2016-04-16: v3.04 - Corrections to reinitialize asserts. Added
    bound-checking asserts to advance/next/prev implementations.</li>
  <li>2016-03-26: v3.03 - Correction to operator = on colony. Replaced
    SDL2/SDL_Timer in benchmarks with plf_nanotimer, a cross-platform
    ~nanosecond-precision timer. Correction to end() and begin() overloads -
    internal begin/end iterator could previously be altered by user activity,
    in some cases. Correction to .next functions.</li>
  <li>2016-03-24: v3.02 - Small performance improvements. Fix for demo for
    regular SDL2 usage. Duplication of macros from plf_stack.h to plf_colony.h
    to fix issue when plf_stack.h is also used within project separately from
    plf_colony.h. </li>
  <li>2016-02-23: v3.01 - Colony now uses a <a
    href="http://www.mediafire.com/download/rp54fr14cqt963c/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> instead of a boolean field, which mitigates worst-case
    scenario performance by factors of ten. Iterators now bidirectional (but
    include &gt; &lt; &gt;= and &lt;= operators) instead of random-access, and
    compliant with C++-specification's time-complexity requirements (all
    operations O(1) amortised). +=, -=, - and + iterator operators relegated to
    advance, distance, next and prev functions under colony. There is greater
    compliance with allocators. Group size now limited to 65535 max for colony,
    to decrease memory wastage and improve skipfield performance. Various
    bugfixes and corrections. plf::stack storage limit no longer 32-bit uint
    max (relies on allocator to supply correct size_type). Added worst-case and
    best-case scenario tests to colony benchmark, and added std::stack
    comparison to plf::stack benchmark. Benchmarks yet to be updated in
  docs.</li>
  <li>2015-11-20: v2.34 - Correction to clear() and reinitialize()
  functions.</li>
  <li>2015-11-17: v2.33 - Minor bugfix for GCC versions &lt; 5.</li>
  <li>2015-11-2: v2.32 - Minor bugfix for non-trivial pointers and non-trivial
    stack contents.</li>
  <li>2015-10-31: v2.31 - Allocators which supply non-trivial pointers are now
    supported. Large macros removed. Some code cleanup and minor performance
    gain.</li>
  <li>2015-10-10: v2.26 - 'back()' in plf::stack changed to 'top()' to better
    reflect std:: library stack implementation function titles. Added standard
    container typedefs to colony and stack. Colony iterators now return
    element_allocator::pointer and element_allocator::reference instead of
    value_type * and value_type &amp;. Some minor code cleanup.</li>
  <li>2015-10-6: v2.24 - Bugfix for C++03 with x64 compilers. Minor
    corrections, performance improvements for C++03 compilers.</li>
  <li>2015-10-4: v2.21 - Improved gcc x64 iteration. std::find now working with
    reverse_iterator. reverse_iterator function corrections, performance
    improvements. Hintless allocators under C++11 now supported. Allocation now
    uses allocator_traits under C++11.</li>
  <li>2015-9-30: v2.13 - Fixed performance regression with small primitive
    types and MS VCC. Small bugfixes.</li>
  <li>2015-9-28: v2.12 - Added const_iterator, const_reverse_iterator, .cbegin,
    .cend, .crbegin, .crend. Some small bugfixes.</li>
  <li>2015-9-27: v2.00 - Larger performance improvements, particularly for
    small primitive type storage. Corrections to exception handling and EBCO.
    ".insert" replaces ".add" (realised there is precedence for
    non-position-based insert via unordered_map/unordered_set). Added postfix
    iterator increment and decrement. Zero-argument ".add()" and ".push()"
    function overloads removed (same thing achievable with
    "colony.insert(value_type());" and "stack.push(value_type());". Many
    bugfixes and general code cleanup.</li>
  <li>2015-9-15: v1.79 - Empty base class allocator optimisations and smaller
    optimisation.</li>
  <li>2015-9-1: v1.77 - Some small bugfixes.</li>
  <li>2015-8-30: v1.76 - Now exception-safe. Also fixed C++03 regression
  bug.</li>
  <li>2015-8-22: v1.75 - Iterators more compliant and now work with std::find
    and should work with other std:: algorithm functions. Native find functions
    removed. (iterator - iterator) and (iterator + iterator) support added
    (relatively useless to end-users, but required by some std::
  algorithms).</li>
  <li>2015-8-15: v1.73 - Correction to noexcept/nothrow use under some
    non-c++11 compilers. Some rvalue functions corrected.</li>
  <li>2015-8-3: v1.72 - Added noexcept to more functions.</li>
  <li>2015-7-20: v1.71 - Small correction to demo, changed a data member name
    in demo to remove conflict in MSVC 2015.</li>
  <li>2015-7-13: v1.70 - Added deque comparisons to performance tests - this
    was necessary because many people were making comparisons between colonies
    and deques, without understanding what a deque is and how it
  performs...</li>
  <li>2015-6-21: v1.69 - Code tidy-up.</li>
  <li>2015-6-16: v1.67 - Correction to VS2013/VS2010 support: move semantics
    and other C++11 facets enabled for MS compilers. Support for VS2012, VS2015
    and later added. Performance bottleneck in destructors in debug mode fixed.
    General cleanup. Some microoptimisations. Macros now better named to avoid
    conflicts.</li>
  <li>2015-5-30: v1.60 - Correction to add function, microoptimizations.</li>
  <li>2015-5-29: v1.53 - Performance improvement. Corrected move constructor
    and reverse_iterator function semantics.</li>
  <li>2015-5-28: v1.52 - Small correction.</li>
  <li>2015-5-26: v1.51 - Small performance improvement. In demo, including
    SDL.h caused some weird behaviour with timer when used, changed to
    SDL_timer.h. Benchmarks to be updated.</li>
  <li>2015-5-25: v1.50 - Microoptimizations, small improvements, fixed crash in
    demo where memory would overflow when compiled to x86 without LAA.</li>
  <li>2015-5-21: v1.43 - Minor performance improvements for release mode,
    larger improvements for debug mode.</li>
  <li>2015-5-16: v1.42 - Some demo corrections.</li>
  <li>2015-5-16: v1.41 - Fixed demo on pre-C++11 compilers. Minor fixes in code
    and corrections in tests. Performance improvements.</li>
  <li>2015-5-11: v1.40 - Improved iterator ++ speed and Add speed, added
    real-world OO performance tests to demo. Added max group-size tuning (max
    number of elements per group).</li>
  <li>2015-5-6: v1.34 - Improved iterator ++ speed under VC2010 and GCC
  x64.</li>
  <li>2015-5-5: v1.33 - Improved erase, and some small performance tweaks.</li>
  <li>2015-5-4: v1.32 - Minor fixes.</li>
  <li>2015-5-3: v1.31 - Resolved all current known edge-case crashes. Improved
    stack pop performance.</li>
  <li>2015-4-26: v1.20 - Found and resolved several edge-case bugs. Improved +,
    -, += and -= iterator operator performance tremendously.</li>
  <li>2015-4-18: v1.10 - Allocators fully supported now. Improved performance.
    Some bugfixes. Added std::iterator trait to iterator. Added large struct
    tests to demo. Improved realism of array tests.</li>
  <li>2015-4-13: v1.00 - Allocators now largely supported (some work to do).
    Erasure bug fixed. First proper release.</li>
  <li>2015-4-9: v0.983 - Updated demo to be more realistic for array usage and
    to run all tests sequentially.</li>
  <li>2015-4-6: v0.982 - Bugfixes, speedup, added find functions.</li>
  <li>2015-4-2: v0.98 - First release</li>
</ul>

<p><a id="contact"></a>Contact: <img alt="footer" src="footer.gif"><br>
plf:: library and this page Copyright (c) 2017, Matthew Bentley</p>
</body>
</html>
