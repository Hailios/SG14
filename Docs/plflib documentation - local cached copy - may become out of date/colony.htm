<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="description" content="PLF C++ Library - plf::colony">
  <meta name="keywords"
  content="C++, C, vector, colony, plf::colony, speed, OO, containers, optimize, performance, pointer, iterator, invalidation">
  <title>PLF C++ Library - plf::colony</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<a href="index.htm">Home</a> 

<h1>PLF C++ Library - plf::colony</h1>
<ul>
  <li><a href="#intro">Intro</a></li>
  <li><a href="#license">License</a></li>
  <li><a href="#download">Download</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#functions">Function Descriptions and Syntax</a></li>
  <li><a href="#faq">Frequently-asked Questions</a></li>
</ul>

<h2><a id="intro"></a>Intro</h2>

<p>A colony is a vector-like template class without pointer/iterator
invalidation and with better performance for larger-than-scalar types (ie.
structs, classes etc). Instead of using one single block of memory and
reallocating, it utilises chains of increasingly-larger memory blocks to form a
cache-contiguous container. Performance is better than std::vector in terms of
adding elements, iteration can be slower or faster than std::vector, depending
on compiler, size of data-type stored and platform it is running on, but in
terms of element deletion colonies are many powers of 10 faster. Using a
boolean field to indicate element deletion, instead of relocating data, the
increasingly large erase times that we typically see with vectors as the data
scale becomes higher are non-existent. A brief visual summary of the
differences between vector allocation and colony allocation follows.</p>

<h3>Adding to a full vector/colony</h3>
<img src="vector_addition.gif"
alt="Visual demonstration of adding to a full vector" height="540" width="960">
<img src="colony_addition.gif"
alt="Visual demonstration of adding to a full colony" height="540" width="960"> 

<h3>Erasing randomly within a vector/colony</h3>
<img src="vector_erasure.gif"
alt="Visual demonstration of randomly erasing from a vector" height="540"
width="960"> <img src="colony_erasure.gif"
alt="Visual demonstration of randomly erasing from a colony" height="540"
width="960"> 

<p>Colonies are best suited for collections of data where order is not
important. Using the add function, new elements may be put in recycled (ie
previously erased) element slots, but otherwise it pushes the data to the back
of the colony much like a vector would. Random placement insertion in colonies
is not possible due to the memory model. Having said all that, using a sort
function with your existing colony data is possible, so sorted content is not
particularly difficult to achieve.</p>

<p>While performance is compiler-dependent (you will get different results
using clang vs gcc, or vc++ vs clang), the greatest performance advantage is
shown in "release" compilation mode ie. -O2 on most compilers - there has been
less optimisation done for debug mode (-O0). The larger the object being store
in the colony is, the greater the speed advantage over vectors tends to be. For
primitive datatypes eg. int's, vectors tend to have an advantage over colonies
in terms of iteration, but not in terms of adding or deleting elements to the
container.</p>

<h2><a id="license"></a>License</h2>

<p>plf::colony is under a permissive <a
href="http://en.wikipedia.org/wiki/Zlib_License">zlib license</a>. This means:
Software is used on 'as-is' basis. It can be modified and used in commercial
software. Authors are not liable for any damages arising from its use. The
distribution of a modified version of the software is subject to the following
restrictions:</p>
<ul>
  <li>The authorship of the original software must not be misrepresented,</li>
  <li>Altered source versions must not be misrepresented as being the original
    software, and</li>
  <li>The license notice must not be removed from source distributions.</li>
</ul>

<h2><a id="download"></a>Download</h2>

<p>Download <a href="plf_colony_2-9-2015.zip">here</a>. (19kb)<br>
The colony library is a simple .h header file, to be included with a #include
command. The package includes the plf::stack .h file, which is used internally
by plf::colony.</p>

<h3>Version history</h3>
<ul>
  <li>2015-9-1: v1.77 - Some small bugfixes.</li>
  <li>2015-8-30: v1.76 - Now exception-safe. Also fixed C++0x regression bug.</li>
  <li>2015-8-22: v1.75 - Iterators more compliant and now work with std::find
    and should work with other std:: algorithm functions. Native find functions
    removed. (iterator - iterator) and (iterator + iterator) support added
    (relatively useless to end-users, but required by some std::
  algorithms).</li>
  <li>2015-8-15: v1.73 - Correction to noexcept/nothrow use under some
    non-c++11 compilers. Some rvalue functions corrected.</li>
  <li>2015-8-3: v1.72 - Added noexcept to more functions.</li>
  <li>2015-7-20: v1.71 - Small correction to demo, changed a data member name
    in demo to remove conflict in MSVC 2015.</li>
  <li>2015-7-13: v1.70 - Added deque comparisons to performance tests - this
    was necessary because many people were making comparisons between colonies
    and deques, without understanding what a deque is and how it
  performs...</li>
  <li>2015-6-21: v1.69 - Code tidy-up.</li>
  <li>2015-6-16: v1.67 - Correction to VS2013/VS2010 support: move semantics
    and other C++11 facets enabled for MS compilers. Support for VS2012, VS2015
    and later added. Performance bottleneck in destructors in debug mode fixed.
    General cleanup. Some microoptimisations. Macros now better named to avoid
    conflicts.</li>
  <li>2015-5-30: v1.60 - Correction to add function, microoptimizations.</li>
  <li>2015-5-29: v1.53 - Performance improvement. Corrected move constructor
    and reverse_iterator function semantics.</li>
  <li>2015-5-28: v1.52 - Small correction.</li>
  <li>2015-5-26: v1.51 - Small performance improvement. In demo, including
    SDL.h caused some weird behaviour with timer when used, changed to
    SDL_timer.h. Benchmarks to be updated.</li>
  <li>2015-5-25: v1.50 - Microoptimizations, small improvements, fixed crash in
    demo where memory would overflow when compiled to x86 without LAA.</li>
  <li>2015-5-21: v1.43 - Minor performance improvements for release mode,
    larger improvements for debug mode.</li>
  <li>2015-5-16: v1.42 - Some demo corrections.</li>
  <li>2015-5-16: v1.41 - Fixed demo on pre-C++11 compilers. Minor fixes in code
    and corrections in tests. Performance improvements.</li>
  <li>2015-5-11: v1.40 - Improved iterator ++ speed and Add speed, added
    real-world OO performance tests to demo. Added max block-size tuning (max
    number of elements per block).</li>
  <li>2015-5-6: v1.34 - Improved iterator ++ speed under VC2010 and GCC
  x64.</li>
  <li>2015-5-5: v1.33 - Improved erase, and some small performance tweaks.</li>
  <li>2015-5-4: v1.32 - Minor fixes.</li>
  <li>2015-5-3: v1.31 - Resolved all current known edge-case crashes. Improved
    stack pop performance.</li>
  <li>2015-4-26: v1.20 - Found and resolved several edge-case bugs. Improved +,
    -, += and -= iterator operator performance tremendously.</li>
  <li>2015-4-18: v1.10 - Allocators fully supported now. Improved performance.
    Some bugfixes. Added std::iterator trait to iterator. Added large struct
    tests to demo. Improved realism of array tests.</li>
  <li>2015-4-13: v1.00 - Allocators now largely supported (some work to do).
    Erasure bug fixed. First proper release.</li>
  <li>2015-4-9: v0.983 - Updated demo to be more realistic for array usage and
    to run all tests sequentially.</li>
  <li>2015-4-6: v0.982 - Bugfixes, speedup, added find functions.</li>
  <li>2015-4-2: v0.98 - First release</li>
</ul>

<h2><a id="benchmarks"></a>Benchmarks</h2>

<p style="font-size: 75%"><i>Last updated 13-7-2015 v1.70</i></p>

<p>All of the benchmarks below are included in the plf_demo.cpp in the
download, anyone can run them. They do not require any external libraries.</p>

<p>My test setup is an E8500 on an Intel motherboard, 8GB ram. Results are much
the same for other x64 platforms. Compilers are mingw TDM GCC 5.1 (32-bit and
64-bit versions), MS VC++ 2010 and MS VC++ 2013. I've ignored clang as the
results were much the same as GCC. Release compilation settings only, no debug
mode. Normal release settings for MS compilers, -O2;-march=native;-std=c++11
for GCC. <a href="http://www.libsdl.org">SDL</a> was used for more precise
timing.</p>

<h3>Real-world Object-Oriented tests</h3>

<h4>Test one: Full add/erase, no invalidation</h4>

<p>Colony was formulated primarily for the situation where we:</p>
<ol type="1">
  <li>wish to be able to dynamically add to a container</li>
  <li>wish to be able to erase container elements</li>
  <li>do not wish to have any pointer/iterator invalidation, so that references
    between objects in containers remain valid</li>
</ol>

<p>Vector and deque only satisfy these demands in one scenario; where we have a
vector/deque of pointers to dynamically-allocated objects. Because the object
itself does not get moved when the vector/deque reallocates (only the pointer),
references between objects stay consistent regardless of what happens in the
vector/deque. Unfortunately as we shall see, the performance of this technique
is less than grand. In addition in the test below I have included comparisons
with std::list and std::map, both of which satisfy the requirements above.</p>

<table style="width: 100%" border="1">
  <caption>Adding 2000000 small structs, each with a random unsigned int as one
  of the members</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector (of pointers to dynamically-allocated objects)</td>
      <td>178</td>
      <td>171</td>
      <td>211</td>
      <td>205</td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>47</td>
      <td>50</td>
      <td>82</td>
      <td>67<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::list</td>
      <td>188</td>
      <td>187</td>
      <td>210</td>
      <td>201<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::map</td>
      <td>371</td>
      <td>382</td>
      <td>464</td>
      <td>413<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque (of pointers to dynamically-allocated objects)</td>
      <td>174</td>
      <td>164</td>
      <td>230</td>
      <td>239<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>3.8x</td>
      <td>3.4x</td>
      <td>2.6x</td>
      <td>3.1x<br>
      </td>
      <td>3.2x<br>
      </td>
    </tr>
  </tbody>
</table>

<table style="width: 100%" border="1">
  <caption>Erasing 1 in every 5000 elements at random</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector (as above)</td>
      <td>322</td>
      <td>1029</td>
      <td>328</td>
      <td>1038<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>30</td>
      <td>28</td>
      <td>37</td>
      <td>29<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::list</td>
      <td>31</td>
      <td>32</td>
      <td>40</td>
      <td>37<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::map</td>
      <td>98</td>
      <td>96</td>
      <td>104</td>
      <td>106<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque (as above)</td>
      <td>173</td>
      <td>329</td>
      <td>918</td>
      <td>1494<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>10.7x</td>
      <td>36.8x</td>
      <td>8.9x</td>
      <td>35.8x<br>
      </td>
      <td>23.1x<br>
      </td>
    </tr>
  </tbody>
</table>

<table style="width: 100%" border="1">
  <caption>Iterating over all elements 100 times and add random unsigned int
  member to a total</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector (as above)</td>
      <td>1568</td>
      <td>2101</td>
      <td>1527</td>
      <td>2097<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>1146</td>
      <td>1477</td>
      <td>1157</td>
      <td>1481<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::list</td>
      <td>1946</td>
      <td>2820</td>
      <td>1960</td>
      <td>2831<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::map</td>
      <td>5311</td>
      <td>5958</td>
      <td>5437</td>
      <td>6005<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque (as above)</td>
      <td>1609</td>
      <td>2121</td>
      <td>1732</td>
      <td>2498<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>1.37x</td>
      <td>1.42x</td>
      <td>1.32x</td>
      <td>1.42x</td>
      <td>1.38x<br>
      </td>
    </tr>
  </tbody>
</table>

<table style="width: 100%" border="1">
  <caption>Clear()'ing containers and deallocating all data</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector (as above)</td>
      <td>79</td>
      <td>51</td>
      <td>65</td>
      <td>52<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>6</td>
      <td></td>
    </tr>
    <tr>
      <td>std::list</td>
      <td>101</td>
      <td>84</td>
      <td>91</td>
      <td>87<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::map</td>
      <td>138</td>
      <td>140</td>
      <td>139</td>
      <td>163<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque (as above)</td>
      <td>100</td>
      <td>81</td>
      <td>115</td>
      <td>123<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>15.8x</td>
      <td>10.2x</td>
      <td>13.0x</td>
      <td>8.7x<br>
      </td>
      <td>11.9x<br>
      </td>
    </tr>
  </tbody>
</table>
<br>


<p>We can see from this that under these circumstances, a colony outperforms
all contenders, in every area.</p>

<h4>Test two: Pre-execution Add, Full erase, no invalidation</h4>

<p>While the above test addresses the primary purpose of colonies, it is also
useful to note there is a second commonly-used scenario - particularly in the
games industry - where pre-execution invalidation is irrelevant. In these
scenarios, what usually happens is an array or vector gets filled with objects,
then none of the objects get deleted for the rest of the execution of one part
of the program - say, a game level - and neither does the container get added
to. This enables the containers to retain pointer and iterator validation, so
they can function in the OO environment during the scope of the execution.
Typically in these circumstances a bool or similar is used to notify the engine
as to which objects are 'active' and which objects are "removed". This
functions as a kind of 'erase' command for objects, without actually freeing
memory or calling destructors. I thought it would be useful to demonstrate the
differences between this approach and colony performance. So to elaborate, the
vector and array in this test reference the same type of struct as the colony
does, but with a 'erased' boolean added to it. This is turned on during
erasure. Neither the array nor the vector has the ability to free up memory or
destruct objects during this process.</p>

<table style="width: 100%" border="1">
  <caption>Adding 5000000 small structs, each with a random unsigned int as one
  of the members</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>331</td>
      <td>300</td>
      <td>453</td>
      <td>505</td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>118</td>
      <td>116</td>
      <td>210</td>
      <td>167</td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>124</td>
      <td>110</td>
      <td>157</td>
      <td>136</td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque</td>
      <td>169</td>
      <td>166</td>
      <td>543</td>
      <td>528</td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>2.8x</td>
      <td>2.6x</td>
      <td>2.2x</td>
      <td>3.0x</td>
      <td>2.7x</td>
    </tr>
  </tbody>
</table>

<table style="width: 100%" border="1">
  <caption>Erasing 1 in every 5000 elements at random</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>67</td>
      <td>61</td>
      <td>90</td>
      <td>69<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>77</td>
      <td>69</td>
      <td>101</td>
      <td>79<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>68</td>
      <td>61</td>
      <td>89</td>
      <td>70<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque</td>
      <td>68</td>
      <td>63</td>
      <td>97</td>
      <td>74<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>0.89x</td>
      <td>0.88x</td>
      <td>0.89x</td>
      <td>0.87x<br>
      </td>
      <td>0.88x<br>
      </td>
    </tr>
  </tbody>
</table>

<table style="width: 100%" border="1">
  <caption>Iterating over all elements 100 times and add random unsigned int
  member to a total</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>2773</td>
      <td>3520</td>
      <td>2864</td>
      <td>3579<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>2926</td>
      <td>3707</td>
      <td>3068</td>
      <td>3773<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>2771</td>
      <td>3490</td>
      <td>2861</td>
      <td>3537<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>std::deque</td>
      <td>2925</td>
      <td>3807</td>
      <td>4235</td>
      <td>5432<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>0.95x</td>
      <td>0.95x</td>
      <td>0.93x</td>
      <td>0.95x<br>
      </td>
      <td>0.95x<br>
      </td>
    </tr>
  </tbody>
</table>
<br>


<p>While we can see that vectors and arrays have a slight lead in iteration
performance in this circumstance, the difference is minimal and while the array
and vector are not freeing up memory or calling destructors, the colony is -
and hence provides more headroom for memory during execution.</p>

<h3>Non-Object-Oriented, "Raw" tests</h3>

<p>In these tests we compare performance where pointer/iterator invalidation
are not a concern. Since list and map are no contenders in this way, the test
will be between std::vector, plf::colony, and a standard C-style array. So, the
vector will use it's normal erase function, house elements normally instead of
pointers to objects. Like the previous test, the array will have a boolean
"erased" flag to mimic erasure. And like the previous test the array is unable
to free up memory or destruct elements. It is merely there for a raw speed
comparison for "fixed size" situations.</p>

<p>There are three tests; one with a simple small struct consisting of 2
doubles, 2 pointers and 2 integers, one with a larger struct containing large
arrays, and one with only unsigned ints to test primitive types. We'll start
with the small structs. Numbers are milliseconds, lower is better.</p>

<h4>Small struct test</h4>

<table style="width: 100%" border="1">
  <caption>Adding 5000000 small structs, each with a random unsigned int as one
  of the members</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>330</td>
      <td>301</td>
      <td>454</td>
      <td>505<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>141</td>
      <td>120</td>
      <td>209</td>
      <td>168<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>125</td>
      <td>110</td>
      <td>157</td>
      <td>136<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>2.3x</td>
      <td>2.5x</td>
      <td>2.2x</td>
      <td>3.0x<br>
      </td>
      <td>2.5x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Erasing 1 in every 5000 elements at random</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>37857</td>
      <td>44893</td>
      <td>36813</td>
      <td>45229<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>78</td>
      <td>71</td>
      <td>93</td>
      <td>87<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>66</td>
      <td>61</td>
      <td>91</td>
      <td>67<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>485.4x</td>
      <td>632.3x</td>
      <td>395.8x</td>
      <td>519.9x</td>
      <td>508.4x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Iterating over all elements 100 times and add random unsigned int
  member to a total</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>3002</td>
      <td>3528</td>
      <td>2928</td>
      <td>3793<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>2853</td>
      <td>3698</td>
      <td>3063</td>
      <td>4014<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>2702</td>
      <td>3470</td>
      <td>2857</td>
      <td>3521<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>1.05x</td>
      <td>0.95x</td>
      <td>0.96x</td>
      <td>0.95x<br>
      </td>
      <td>0.98x<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>


<h4>Large struct test</h4>

<table style="width: 100%" border="1">
  <caption>Adding 10000 large structs, each with a random unsigned int as one
  of the members</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>313</td>
      <td>261</td>
      <td>437</td>
      <td>460<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>97</td>
      <td>101</td>
      <td>98</td>
      <td>103<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>95</td>
      <td>100</td>
      <td>94</td>
      <td>99<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>3.2x</td>
      <td>2.6x</td>
      <td>4.5x</td>
      <td>4.5x<br>
      </td>
      <td>3.7x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Erasing 1 in every 50 elements at random</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>7249</td>
      <td>6187</td>
      <td>7177</td>
      <td>7316<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>&lt; 1</td>
      <td>&lt; 1</td>
      <td>1</td>
      <td>1<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>1</td>
      <td>1</td>
      <td>&lt; 1</td>
      <td>0<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>&gt; 7249x</td>
      <td>&gt; 6187x</td>
      <td>7177x</td>
      <td>7316x<br>
      </td>
      <td>&gt; 6982x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Iterating over all elements 100 times and add random unsigned int
  member to a total</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>477</td>
      <td>479</td>
      <td>479</td>
      <td>587<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>515</td>
      <td>509</td>
      <td>568</td>
      <td>649<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>519</td>
      <td>529</td>
      <td>511</td>
      <td>529<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>0.93x</td>
      <td>0.94x</td>
      <td>0.84x</td>
      <td>0.90x<br>
      </td>
      <td>0.90x<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>


<h4>Small primitive type test</h4>

<table style="width: 100%" border="1">
  <caption>Adding 5000000 random unsigned ints</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MS VC++ 2010 (x86)</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>93</td>
      <td>80</td>
      <td>125</td>
      <td>103<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>76</td>
      <td>69</td>
      <td>136</td>
      <td>99<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>71</td>
      <td>65</td>
      <td>94</td>
      <td>76<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>1.2x</td>
      <td>1.2x</td>
      <td>0.9x</td>
      <td>1.0x<br>
      </td>
      <td>1.1x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Erasing 1 in every 5000 elements at random</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MS VC++ 2010 (x86)</td>
      <td>MS VC++ 2013 (x64)</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>3743</td>
      <td>3705</td>
      <td>3773</td>
      <td>3760<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>78</td>
      <td>62</td>
      <td>98</td>
      <td>80<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>67</td>
      <td>60</td>
      <td>91</td>
      <td>68<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>48.0x</td>
      <td>59.8x</td>
      <td>38.5x</td>
      <td>47.0x<br>
      </td>
      <td>48.3x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<table style="width: 100%" border="1">
  <caption>Iterating over all elements 100 times and adding to a total</caption>
  <colgroup><col>
    <col>
    <col>
    <col>
    <col>
  </colgroup>
  <tbody>
    <tr>
      <td>Total duration in ms</td>
      <td>GCC 5.1 x86</td>
      <td>GCC 5.1 x64</td>
      <td>MSVC 2010 x86</td>
      <td>MSVC 2013 x64</td>
      <td>Average</td>
    </tr>
    <tr>
      <td>std::vector</td>
      <td>1226</td>
      <td>459</td>
      <td>459</td>
      <td>461<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>plf::colony</td>
      <td>1241</td>
      <td>844</td>
      <td>1232</td>
      <td>972<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>array</td>
      <td>1271</td>
      <td>674</td>
      <td>677</td>
      <td>679<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>colony vs vector performance</td>
      <td>0.99x</td>
      <td>0.54x</td>
      <td>0.37x</td>
      <td>0.47x<br>
      </td>
      <td>0.59x<br>
      </td>
    </tr>
  </tbody>
</table>

<p></p>

<h2><a id="functions"></a>Function Descriptions and syntax</h2>

<p>For the most part the syntax and semantics of colony functions are very
similar to all std:: c++ libraries. However there are a few key differences,
such as the meaning of using a number in the constructor.</p>

<h3>Constructors</h3>
<ul>
  <li><code>colony&lt;the_type&gt; a_colony</code> 
    <p>Default constructor - group size is initially 8. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony;</code> </p>
  </li>
  <li><code>colony&lt;the_type, the_allocator&lt;the_type&gt; &gt;
    a_colony</code> 
    <p>Default constructor, but using a custom memory allocator eg. something
    other than std::allocator. Custom allocators can also be used with all the
    definitions below, of course. <br>
    Example: <code style="color: brown">plf::colony&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_colony;</code> </p>
  </li>
  <li><code>colony&lt;the_type&gt; a_colony(initial_group_size)</code> 
    <p>Directed constructor where the initial group size is defined. For
    example if it were 50, the max number of elements in the first colony group
    would be 50 - the next group would have 100, and so on. Unlike a vector,
    these 50 elements are not constructed, only the memory is allocated. By
    default the first group size is 8. A minor performance advantage can be had
    by using this constructor feature if you know in advance roughly how many
    objects are likely to be stored in your colony - or at least the rough
    scale of storage. This would stop many small initial groups being
    created.<br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony(62);</code></p>
  </li>
  <li><code>colony&lt;the_type&gt; a_colony(initial_group_size,
    maximum_group_size)</code> 
    <p>Like the above this is a directed constructor - the first number sets
    the number of elements in the first group, while the second number sets the
    absolute maximum number of elements any given group may hold ie. Once a
    group reaches this size, further groups will not increase in size. By
    default the maximum size a colony group can reach is half of UINT_MAX (ie.
    half the maximum unsigned int size for any given compiler). This could be
    useful in a scenario where memory is at a premium and where large amounts
    of erasures are occuring. In that situation, by defining a lower group size
    you increase the likelihood of any given group becoming empty and hence
    deallocated and freed to system memory.<br>
    Example: <code style="color: brown">plf::colony&lt;int&gt; int_colony(64,
    512);</code></p>
  </li>
  <li><code>colony&lt;the_type&gt; a_colony(another_colony)</code> 
    <p>Copy constructor - copies all contents from another_colony, removes any
    empty (erased) element spaces. Initial group size is the total size of
    another_colony. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(int_colony_1);</code></p>
  </li>
  <li><code>colony&lt;the_type&gt; a_colony(std::move(another_colony))</code> 
    <p>Move constructor - moves all contents from another colony, does not
    remove any erased elements or alter any group sizes. another_colony is now
    void of contents, can be safely destructed. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(std::move(int_colony_1));</code></p>
  </li>
</ul>

<h3>Iterators/Reverse_iterators</h3>

<p>Similar to all std:: iterators. Functionality for
plf::colony&lt;&gt;::iterator and plf::colony&gt;&lt;&gt;::reverse_iterator
below:</p>
<code>*<br>
-&gt;<br>
++<br>
--<br>
+=<br>
-=<br>
+<br>
-<br>
=<br>
==<br>
!=<br>
&gt;<br>
&lt;<br>
&gt;=<br>
&lt;=</code> 

<p>Greater-than/lesser-than usage indicates whether an iterator is higher/lower
in position compared to another iterator in the same colony (ie. closer to the
end/beginning).</p>

<p>reverse_iterator also has the base() command (same as STL) to return the
internal iterator.</p>

<p>Colony contains begin(), end(), rbegin() and rend() iterator return
functions which follow standard std:: library rules. Example of usage:</p>
<code style="color: brown">for (plf::colony&lt;int&gt;::iterator the_iterator =
data_colony.begin(); the_iterator != data_colony.end(); ++the_iterator)<br>
{<br>
   total += *the_iterator;<br>
}</code>

<h3>Basic functions</h3>
<ul>
  <li><code>iterator add(const the_type &amp;element)</code> 
    <p>Adds the element supplied to the colony, using the object's
    copy-constructor. Will place the element in a previously erased element
    slot if one exists, otherwise will push to back of colony. Returns iterator
    to location of pushed element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    data_colony.add(23);</code> </li>
  <li><code>iterator add(the_type &amp;&amp;element) <b>C++11 only</b></code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will place the element in a previously erased element
    slot if one exists, otherwise will push to back of colony. Returns iterator
    to location of pushed element. Example:</p>
    <p><code style="color: brown">struct just_struct<br>
    {<br>
      unsigned int number;<br>
      std::string string1;<br>
    };<br>
    <br>
    just_struct X;<br>
    X.number = 5;<br>
    X.string1 = "Some text";<br>
    <br>
    plf::colony&lt;just_struct&gt; data_colony(50);<br>
    data_colony.add(std::move(X));</code> </p>
  </li>
  <li><code>void add(iterator begin_iterator, iterator end_iterator)</code> 
    <p>Adds the contents of a colony of same element type (eg. int, float, a
    particular class, etcetera) to the given colony. Stops adding once it
    reaches the end iterator. Example:</p>
    <code style="color: brown">// Add all contents of colony2 to colony1:<br>
    colony1.add(colony2.begin(), colony2.end());</code> </li>
  <li><code>iterator add()</code> 
    <p>Semantics are the same as "add(the_type())". This is simple
    initialisation without writing any data to the element (at least, any data
    that isn't written by the type's constructor). If the datatype is a class
    this requires a default, parameterless, constructor (and typically a
    separate initialisation function).<br>
    If the datatype is a constructorless struct or primitive type eg. int, it
    simply leaves the new object in an uninitialised state. In either case it
    returns the constructed object/data location so you can access it and write
    to it directly. This could be useful when you have a large class object and
    you want to write directly to it within the colony rather than wasting CPU
    cycles constructing it and then copying it to the colony. Also useful where
    C++11 semantics (ie. emplace) are unavailable. A very simple (and unlikely)
    example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator place;<br>
    place = data_colony.add();<br>
    *place = 23;</code> </li>
  <li><code>iterator emplace(parameters...) <b>C++11 only</b></code> 
    <p>Same as Add but constructs object in-place rather than copying another
    object into the colony. Similar to std:: library emplace with the exception
    that no insertion location is specified. Location depends on same behaviour
    as Add. "parameters..." are whatever parameters are required by the
    object's constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
     int number;<br>
    public:<br>
     simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>iterator erase(const iterator &amp;the_iterator)</code> 
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Similarly to STL erase command, returns an iterator pointing to the
    next non-erased element in the colony (or to end() if no more elements are
    available). Must return an iterator because if a colony group becomes
    entirely empty, it will be removed from the colony, invalidating the
    existing iterator. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.add(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const iterator &amp;begin_iterator, const iterator
    &amp;end_iterator)</code> 
    <p>Erases all contents of a given colony from the begin_iterator to the
    element before the end_iterator. Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin() + 10;<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin() + 20;<br>
    colony1.erase(iterator1, iterator2);</code> </li>
  <li><code>Assignment (=), move assignment (std::move), comparison (==) and
    not-comparison (!=)</code> 
    <p>Standard assignment/move-assignment operators. Example:</p>
    <code style="color: brown">// Manual swap in C++0x<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code><br>
    <code style="color: brown">// Manual swap in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code> </li>
  <li><code>Comparison (==) and not-comparison (!=)</code> 
    <p>These check that the content of the two colonies are the same - not that
    they are the same colony. Will abort if they are the same colony.
    Example:</p>
    <code style="color: brown">if (colony1 == colony2) {   std::cout &lt;&lt;
    "Somehow the contents match!" &lt;&lt; std::endl; } </code></li>
  <li><code>void clear()</code> 
    <p>Removes all content from colony.</p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns empty status of colony.</p>
  </li>
  <li><code>unsigned int size()</code> 
    <p>Returns number of elements in colony.</p>
  </li>
  <li><code>void reinitialize(unsigned int _elements_per_group, (optional)
    unsigned int _max_elements_per_group)</code> 
    <p>Removes all content from colony and reinitialises using the supplied
    elements_per_group as the initial group size, and (optionally) the supplied
    max_elements_per_group as the maximum size of any colony group. If
    max_elements_per_group is not specified the prior maximum of the colony
    will be used.</p>
  </li>
  <li><code>iterator begin(), iterator end()</code> 
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony (as per standard STL
    guidelines).</p>
  </li>
  <li><code>reverse_iterator rbegin(), reverse_iterator rend()</code> 
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony (as
    per standard STL guidelines).</p>
  </li>
</ul>

<h2><a id="faq"></a>Frequently Asked Questions</h2>
<ol>
  <li><h4>TLDR, what is a colony?</h4>
    <p>A combination of a linked-list of memory blocks, combined with a boolean
    erasure field, combined with custom memory location stack, which results in
    a std::-style C++ container with better performance characteristics than
    most std:: containers.</p>
  </li>
  <li><h4>Where should it be used in place of the other std:: containers?</h4>
    <p>It should be used for performance reasons in any situation where the
    order of container elements is not important, and:</p>
    <ol type="a">
      <li>Pointers and iterators which point to container elements must stay
        valid regardless of container additions and deletions,<br>
        <br>
        <b>and/or</b><br>
      </li>
      <li>Additions to or deletions from the container will be occuring in
        realtime ie. in performance-critical code.</li>
    </ol>
    <p>Under these circumstances a colony out-performs all std:: containers.<br>
    In addition: because it never invalidates pointer or iterator references to
    container elements (except when the element being referred to has been
    previously erased) it can make many tasks involving interrelating
    structures in an object-oriented environment much easier, and should be
    considered in those circumstances.</p>
  </li>
  <li><h4>What are the performance characteristics?</h4>
    <p>As above, also, see the <a href="#benchmarks">benchmarks</a>. On
    larger-than-scalar types, adding to a colony is typically twice as fast as
    a vector, erasing from is many multiples-of-ten faster, and iteration about
    the same (or slightly slower, but not by a meaningful ratio). For scalar
    types (ie. int, float etc) it does not perform as well.</p>
  </li>
  <li><h4>What are some examples of situations where a colony improves
    performance?</h4>
    <p>Some ideal situations to use a colony: quadtree, persistent octtree,
    "enemy entities" or destructible-object containers in a video game,
    particle objects, etc, etc.<br>
    Also, anywhere where a vector of pointers to dynamically-allocated objects
    would typically end up being used, in order to preserve object
    references.</p>
  </li>
  <li><h4>Are there situations where one would prefer a vector over a
    colony?</h4>
    <p>Yes, in the circumstance where all additions to and deletions from a
    container occur outside of performance-critical areas of code, while the
    main code merely iterates over the container and never adds or deletes from
    the container, you may find a vector more performant, provided nothing has
    to refer to individual container elements in other sections of the program
    (which would necessitate a vector of pointers to dynamically-allocated
    objects in order to ensure reference validity - which has poor cache
    performance).</p>
    <p>Also, as noted, a vector is easier to use when dealing with ordered
    data. You may sort the data in a colony by iterating over it with a
    swapping/sorting function, but you cannot control insertion placement.</p>
  </li>
  <li><h4>Is it similar to a deque?</h4>
    <p>No, a deque is very disimilar to a colony. A deque is a double-ended
    queue, which requires a very different internal framework. It may or may
    not use a linked-list of memory blocks, dependent on the compiler, and has
    no comparable performance characteristics. Deque element erasure varies
    quite wildly depending on the compiler compared to std::vector, and it does
    not free unused memory blocks to the OS once they are empty, unlike a
    colony. In addition a deque invalidates references to subsequent container
    elements when erasing elements, which a colony does not. A colony never
    invalidates pointers/iterators to elements unless the element being
    referred to is erased.</p>
  </li>
  <li><h4>What is it most similar to?</h4>
    <p>A vector. Because the performance characteristics are more similar
    (better cache performance) and also because colonies follow the same
    doubling-of-memory-space-on-expansion rule that vectors do, colonies are
    probably more similar to a vector despite using a very different internal
    schema.</p>
  </li>
  <li><h4>Why is the function called "add" instead of "insert" or "push"?</h4>
    <p>Because the semantics are different to insert or push.<br>
    Insert always takes an insertion position, add doesn't take a position.<br>
    Push is always accompanied by both "back" and "pop" functions, neither of
    which are used in colonies, and it does not return an iterator, which "add"
    must do.<br>
    "Push" is probably the closest in terms of semantics, but I chose a
    different name to be clear.</p>
  </li>
  <li><h4>Will ordered insert be added to the functions?</h4>
    <p>It is possible, and would be much faster than vector's insert - as
    reallocation would only be necessary for the particular memory block the
    insertion occured in - not all elements after the insertion point, ala
    vector - which could result in ordered insertion times between 1000x and 2x
    faster than vector, depending on where the insertion occurs. However one of
    the main points in making this container was to preserve element
    references, and position-based insert would of course invalidate that
    principle. In addition, adding ordered insertion to colony would also
    result in push_back being a desired function, which users would likely use
    in a naive sense, thinking that, like vector, push_back would be fastest
    (in this case it would be, but it would make iteration slower as unused
    memory slots would not get recycled and hence you would end up with
    redundant space). I've more-or-less decided that adding the ability to
    order element insertion disrupts a colony's natural potential, and have
    avoided it. Having said that, I am looking at it, but only as a
    proof-of-concept.</p>
  </li>
  <li><h4>Will a [ ] operator be added?</h4>
    <p>No. The internal implementation of colony[10] would be colony.begin() +
    10 - and there is no way around this due to the erased element slots, which
    must be incremented over, and due to the fact that a colony frees empty
    memory blocks to the OS. Since using [ ] repeatedly would be very
    inefficient (involving multiple incrementations over the begin() iterator)
    compared to simply using an incrementing iterator starting from begin(), it
    is better the user realise what they are doing, rather than having it
    obsfucated from them.</p>
  </li>
  <li><h4>Any "gotcha"'s to watch out for?</h4>
    <p>Only a few:</p>
    <ol type="a">
      <li>"add" placement can be at the back, front, or frankly anywhere in the
        container, depending on what's been deleted previously and where it
      was.</li>
      <li><code>plf::colony&lt;int&gt; a_colony(500);</code> does not mean the
        same thing as <code>std::vector&lt;int&gt; a_vector(500);</code>. A
        vector inserts 500 elements using the type's default constructor when
        "(500)" is specified, a colony creates it's first memory block to be
        500 elements big but does not insert the empty elements ie. it's the
        same as vector.reserve(500).<br>
        The only difference is because it occurs during construction, it
        doesn't waste CPU cycles deallocating and reallocating memory.<br>
        It can be combined with a maximum-block-size specifier as per the faq
        entry below.</li>
      <li>While you Can subtract the value of the .begin() iterator from the
        current position iterator to get a colony "index" number like you would
        with vector, this is slow and not a useful practice - the ability to do
        so is primarily included for compatibility with std::find and other
        std:: algorithms. Index numbers will be invalidated in colonies by
        erasures (just like other standard containers), whereas iterators and
        pointers are not.</li>
      <li>Once an element has been erased, any iterator or pointer pointing to
        that element is no longer valid. This is the same as vector and other
        std:: container rules, but not the same as an array. In this case, the
        memory block the iterator pointed to may no longer exist. This is the
        only way that iterators and pointers to a colony element can become
        invalidated.</li>
    </ol>
  </li>
  <li><h4>Any special-case uses?</h4>
    <p>In the special case where many, many elements are being continually
    erased/added in realtime, you might want to consider limiting the size of
    your internal memory blocks in the constructor. The form of this is as
    follows:<br>
    <code>plf::vector&lt;object&gt; a_vector(500, 5000);</code><br>
    where the first number is the minimum size of the internal memory blocks
    and the second is the maximum size.<br>
    The reason for this is that it is, slightly, slower to pop an element
    location off the internal memory position recycling stack, than it is to
    add a new element to the end of the colony (the default behaviour when
    there are no previously-erased elements). If there are any erased elements
    in the colony, the colony will recycle those memory locations, unless the
    entire block is empty, at which point it is freed to memory. If a block
    size is too big and many, many erasures occur, the number of erased element
    locations in the recycling stack can get very large before the entire block
    is empty. In that case you may want to run a benchmark limiting the maximum
    size of the blocks, and tune it until you find optimal usage.</p>
  </li>
</ol>
<br>
<br>


<p>Contact: <img src="footer.gif"><br>
plf:: library and this page Copyright (c) 2015, Matthew Bentley</p>
</body>
</html>
