<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="description" content="PLF C++ Library - plf::stack">
  <meta name="keywords"
  content="C++, C, vector, stack, plf::stack, containers, optimize, performance, pointer, iterator, invalidation, benchmarks, results, benchmark, vs, versus, std::vector, std::deque, deque, std::stack">
  <title>PLF C++ Library - plf::stack</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<a href="index.htm">Home</a>

<h1>PLF C++ Library - plf::stack</h1>

<h2>Intro</h2>

<p>plf::stack is used internally by <a href="colony.htm">plf::colony</a> but
can also be used on it's own. It is, basically, a more efficient implementation
of the STL's std::stack functionality, faster than all std:: containers in the
context of a stack. It uses the same <a
href="chained_group_allocation_pattern.htm">chained-group memory allocation pattern</a> as plf::colony, and like plf::colony it never invalidates
references/pointers to non-popped elements, making it better for programming with containers of interrelated data structures.</p>

<h2><a id="license"></a>License</h2>

<p>plf::stack is under a permissive <a
href="http://en.wikipedia.org/wiki/Zlib_License">zlib license</a>. This means:
Software is used on 'as-is' basis. It can be modified and used in commercial
software. Authors are not liable for any damages arising from its use. The
distribution of a modified version of the software is subject to the following
restrictions:</p>
<ul>
  <li>The authorship of the original software must not be misrepresented,</li>
  <li>Altered source versions must not be misrepresented as being the original
    software, and</li>
  <li>The license notice must not be removed from source distributions.</li>
</ul>

<h2>Download</h2>

<p>Download on the plf::colony page <a href="colony.htm#download">here</a>.<br>
Both plf::stack and plf::colony are simple .h header files, to be included with
a #include command. The package includes both plf::colony and plf::stack.</p>

<h2>Benchmarks</h2>
<p style="font-size: 75%"><i>Last updated 16-04-2016 v3.04</i></p>

<p>The test setup is an E8500 on an Intel motherboard, 8GB ram, running GCC 5.1 x64 as compiler. Build settings are "-O2;-march=native;-std=c++11;-fomit-frame-pointer". Results for Microsoft Visual Studio 2013 can be found <a href="stack_msvc_results.htm">here</a>. Tests are based on a sliding scale of number of runs vs number of elements, so a test with only 10 elements in a container may average 100000 runs, whereas a test with 100000 elements may only average 10 runs. This tends to give adequate results without overly lengthening test times. I have not included results involving 'reserve()' functions as the differences to overall insertion performance were not adequate. Reserve testing does not make significant sense for an extensible container, as the entire benefit of such is that we can adapt to situations where we do not know the total number of elements in advance.</p>

<p>Tests are carried out on the following types: (a) a 8-bit type ie. char, (b) a 32-bit type ie. int, (c) a 64-bit type ie. double, (d) a small struct containing two pointers and four scalar types, and (e) a large struct containing 2 pointers, 4 scalar types, a large array of ints and a small array of chars. In order to better facilitate accurate time-keeping for short tests, both container construction and destruction times are included in the tests. The sequence is as follows: construction, push N elements, read (back) + pop all elements, destruction. Because unlike a regular container, a stack must be pushed for every pop, and popped for every read, it makes little sense to analyse these aspects of use separately, as what is most important is the overall time taken. For that reason (and for the sake of simplicity) only total time benchmarks are presented below, however the separate timings are <a href="stack_all_gcc_results.htm">here</a>, for anyone interested.</p>

<img alt="test result graph" src="tests/gcc/stack/char_total_time.png">
<img alt="test result graph" src="tests/gcc/stack/char_total_time_log.png"><br>
<img alt="test result graph" src="tests/gcc/stack/int_total_time.png">
<img alt="test result graph" src="tests/gcc/stack/int_total_time_log.png"><br>
<img alt="test result graph" src="tests/gcc/stack/double_total_time.png">
<img alt="test result graph" src="tests/gcc/stack/double_total_time_log.png"><br>
<img alt="test result graph" src="tests/gcc/stack/small_struct_total_time.png">
<img alt="test result graph" src="tests/gcc/stack/small_struct_total_time_log.png"><br>
<img alt="test result graph" src="tests/gcc/stack/large_struct_total_time.png">
<img alt="test result graph" src="tests/gcc/stack/large_struct_total_time_log.png"><br>

<h4>Conclusion</h4>

<p>Simply put, plf::stack out-performs both std::stack (std::deque) and std::vector, and we can see that the larger the stored type is, the greater the performance advantage is. For scalar types std::stack (std::deque) out-performs plf::colony when the number of elements is low (under 100 for double, under 1000 for char). But in all other areas plf::stack dominates, and has a secondary advantage over std::vector in that pointers to it's elements (as obtained via back() after a push() operation) will not invalidate on subsequent pushes. std::vector will invalidate pointers to stack elements upon subsequent pushes, std::stack will not if it is wrapping a std::deque. The overall recommendation is to use plf::stack in all areas.</p>

<p>plf::stack:<br>
<font style="color: green">Advantages: Fastest general performance. Performance advantage increases with size of stored element. Pointers to stored elements never invalidate.</font><br>
<font style="color: red">Disadvantages: None.</font>
</p>
<p>std::stack (wrapping std::deque):<br>
<font style="color: green">Advantages: Fastest performance for scalar types when number of elements is between roughly 20 and 100-1000 (this last depends on size of type - 64-bit types will be closer to 100, 8-bit closer to 1000). Pointers to stored elements never invalidate.</font><br>
<font style="color: red">Disadvantages: Lower performance with larger-than-scalar types (structs and classes) and in all other areas. std::stack is not guaranteed to be wrapping a std::deque depending on the implementation, and std::deque implementation structure is also compiler-dependent, so the above advantages will not apply generically.</font>
</p>
<p>std::vector:<br>
<font style="color: green">Advantages: None.</font><Br>
<font style="color: red">Disadvantages: Slower than other methods. Invalidates pointers to stored elements on subsequent pushes.</font>
</p>


<h2>Function Descriptions and syntax</h2>

<h3>Constructors</h3>
<ul>
  <li><code>stack&lt;the_type&gt; a_stack</code> 
    <p>Default constructor - initial group size is 8.<br>
    Example: <code style="color: brown">plf::stack&lt;int&gt; int_stack;</code>
    </p>
  </li>
  <li><code>stack&lt;the_type, custom_allocator&lt;the_type&gt; &gt;
    a_stack</code> 
    <p>Default constructor, but using a custom allocator eg. something other
    than std::allocator. Custom allocators can also be used with all the
    definitions below, of course. <br>
    Example: <code style="color: brown">plf::stack&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_stack;</code> </p>
  </li>
  <li><code>stack&lt;the_type&gt; a_stack(const size_type
    initial_group_size)</code> 
    <p>Directed constructor - this sets the initial group size - for example,
    to 50 (unlike a vector, these 50 elements are not constructed, only the
    memory is allocated and the initial group-size set at 50 instead of 8) -
    which may yield a minor performance advantage if you know roughly how many
    elements are going to be stored in your stack in advance. Minimum group
    size is 3.<br>
    Example: <code style="color: brown">plf::stack&lt;int&gt;
    int_stack(62);</code></p>
  </li>
  <li><code>stack&lt;the_type&gt; a_stack(const size_type initial_group_size,
    const size_type max_group_size)</code> 
    <p>Directed constructor - this sets the initial first group size like the
    above, and the maximum group size - this can be useful if you want to limit
    memory usage. Minimum initial group size is 3.<br>
    Example: <code style="color: brown">plf::stack&lt;int&gt; int_stack(64,
    512);</code></p>
  </li>
  <li><code>stack&lt;the_type&gt; a_stack(const stack &amp;
    another_stack)</code> 
    <p>Copy constructor - copies all contents from another_stack. Initial group
    size is the total size of another_stack. <br>
    Example: <code style="color: brown">plf::stack&lt;int&gt;
    int_stack_2(int_stack_1);</code></p>
  </li>
  <li><code>stack&lt;the_type&gt; a_stack(stack &amp;&amp; another_stack)
    <b>C++11 only</b></code> 
    <p>Move constructor - moves all contents from another_stack, does not alter
    any group sizes. Another_stack is now void of contents, can be safely
    destructed. <br>
    Example: <code style="color: brown">plf::stack&lt;int&gt;
    int_stack_2(std::move(int_stack_1));</code></p>
  </li>
</ul>

<h3>Other functions</h3>
<ul>
  <li><code>void push(const the_type &amp;element)</code> 
    <p>Push an element to the stack.<br>
    Example: <code style="color: brown">object_stack.push(object1);</code></p>
  </li>
  <li><code>void push(the_type &amp;&amp;element) <b>C++11 only</b></code> 
    <p>Move an element to the stack.<br>
    Example: <code
    style="color: brown">object_stack.push(std::move(object1));</code></p>
  </li>
  <li><code>void emplace(Arguments ...parameters) <b>C++11 only</b></code> 
    <p>Constructs an element directly on the stack using the the constructor
    arguments specified.<br>
    Example: <code style="color: brown">object_stack.emplace(10, 200,
    "a");</code></p>
  </li>
  <li><code>void pop()</code> 
    <p>Pop the last push()'d element off the stack.<br>
    Example: <code style="color: brown">object_stack.pop();</code></p>
  </li>
  <li><code>the_type &amp; top()</code> 
    <p>Return a reference to the last push()'d element on the stack.<br>
    Example: <code style="color: brown">object2 = object_stack.top();</code></p>
  </li>
  <li><code>size_type size()</code> 
    <p>Return the current number of elements stored on the stack.<br>
    Example: <code style="color: brown">unsigned int j =
    static_cast&lt;unsigned int&gt;(object_stack.size());</code></p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns a boolean indicating whether the stack is currently empty of
    elements.<br>
    Example: <code style="color: brown">if (object_stack.empty())
    return;</code></p>
  </li>
  <li><code>void clear()</code> 
    <p>Empties the stack and removes all elements. Deallocates all groups and
    creates a new starting group of the same size as the original starting
    group (8, unless specified otherwise by the constructor or reinitialize
    call).<br>
    Example: <code style="color: brown">object_stack.clear();</code></p>
  </li>
  <li><code>void reinitialize(const size_type new_size)</code> 
    <p>Clears the stack, creates a new starting group of the size specified.<br>
    Example: <code
    style="color: brown">object_stack.reinitialize(1000);</code></p>
  </li>
  <li><code>void reinitialize(const size_type new_size, const size_type
    maximum_size)</code> 
    <p>Clears the stack, creates a new starting group of the size specified,
    with the maximum potential group size set to maximum_size.<br>
    Example: <code style="color: brown">object_stack.reinitialize(1000,
    100000);</code></p>
  </li>
  <li><code>stack &amp; operator = (const stack &amp;source)</code> 
    <p>Copy the elements from another stack to this stack, clearing this stack
    of existing elements first.<br>
    Example: <code style="color: brown">object_stack = object_stack2;</code></p>
  </li>
  <li><code>stack &amp; operator = (const stack &amp;&amp;source) <b>C++11
    only</b></code> 
    <p>Move the elements from another stack to this stack, clearing this stack
    of existing elements first. Source stack becomes invalid but can be safely
    destructed without undefined behaviour.<br>
    Example: <code style="color: brown">object_stack =
    std::move(object_stack2);</code></p>
  </li>
  <li><code>bool operator == (const stack &amp;source)</code> 
    <p>Compare contents of another stack to this stack. Returns a boolean as to
    whether they are equal.<br>
    Example: <code style="color: brown">if (object_stack == object_stack2)
    return;</code></p>
  </li>
  <li><code>bool operator != (const stack &amp;source)</code> 
    <p>Compare contents of another stack to this stack. Returns a boolean as to
    whether they are not equal.<br>
    Example: <code style="color: brown">if (object_stack != object_stack2)
    return;</code></p>
  </li>
</ul>
<br>


<p>Contact: <img src="footer.gif"><br>
plf:: library and this site Copyright (c) 2016, Matthew Bentley</p>
</body>
</html>
